Command	Type
Catalan	constant.language	Catalan=Catalan(): Catalan's number with current precision.
Col	entity.name.function	Col(x, {n}): transforms the object x into a column vector of dimension n.
Colrev	entity.name.function	Colrev(x, {n}): transforms the object x into a column vector of dimension n in reverse order with respect to Col(x, {n}). Empty vector if x is omitted.
Euler	constant.language	Euler=Euler(): Euler's constant with current precision.
I	constant.language	I=I(): square root of -1.
List	entity.name.function	List({x=[]}): transforms the vector or list x into a list. Empty list if x is omitted.
Map	entity.name.function	Map({x}): converts the matrix [a_1,b_1;a_2,b_2;...;a_n,b_n] to the map a_i->b_i.
Mat	entity.name.function	Mat({x=[]}): transforms any GEN x into a matrix. Empty matrix if x is omitted.
Mod	entity.name.function	Mod(a,b): create 'a modulo b'.
O	entity.name.function	O(p^e): p-adic or power series zero with precision given by e.
Pi	constant.language	Pi=Pi(): the constant pi, with current precision.
Pol	entity.name.function	Pol(t,{v='x}): convert t (usually a vector or a power series) into a polynomial with variable v, starting with the leading coefficient.
Polrev	entity.name.function	Polrev(t,{v='x}): convert t (usually a vector or a power series) into a polynomial with variable v, starting with the constant term.
Qfb	entity.name.function	Qfb(a,{b},{c}): binary quadratic form a*x^2+b*x*y+c*y^2.
Ser	entity.name.function	Ser(s,{v='x},{d=seriesprecision}): convert s into a power series with variable v and precision d, starting with the constant coefficient.
Set	entity.name.function	Set({x=[]}): convert x into a set, i.e. a row vector with strictly increasing coefficients. Empty set if x is omitted.
Str	entity.name.function	Str({x}*): concatenates its (string) argument into a single string.
Strchr	entity.name.function	Strchr(x): deprecated alias for strchr.
Strexpand	entity.name.function	Strexpand({x}*): deprecated alias for strexpand
Strprintf	entity.name.function	Strprintf(fmt,{x}*): deprecated alias for strprintf.
Strtex	entity.name.function	Strtex({x}*): deprecated alias for strtex.
Vec	entity.name.function	Vec(x, {n}): transforms the object x into a vector of dimension n.
Vecrev	entity.name.function	Vecrev(x, {n}): transforms the object x into a vector of dimension n in reverse order with respect to Vec(x, {n}).
Vecsmall	entity.name.function	Vecsmall(x, {n}): transforms the object x into a VECSMALL of dimension n.
abs	entity.name.function	abs(x): absolute value (or modulus) of x.
acos	entity.name.function	acos(x): arc cosine of x.
acosh	entity.name.function	acosh(x): inverse hyperbolic cosine of x.
addhelp	entity.name.function	addhelp(sym,str): add/change help message for the symbol sym.
addprimes	entity.name.function	addprimes({x=[]}): add primes in the vector x to the prime table to be used in trial division. x may also be a single integer. Composite "primes" are NOT allowed.
agm	entity.name.function	agm(x,y): arithmetic-geometric mean of x and y.
airy	entity.name.function	airy(z): Airy [Ai,Bi] function of argument z.
alarm	entity.name.function	alarm({s = 0},{code}): if code is omitted, trigger an "e_ALARM" exception after s seconds (wall-clock time), cancelling any previously set alarm; stop a pending alarm if s = 0 or is omitted. Otherwise, evaluate code, aborting after s seconds.
algadd	entity.name.function	algadd(al,x,y): element x+y in al.
algalgtobasis	entity.name.function	algalgtobasis(al,x): transforms the element x of the algebra al into a column vector on the integral basis of al.
algaut	entity.name.function	algaut(al): the stored automorphism of the splitting field of the cyclic algebra al.
algb	entity.name.function	algb(al): the element b of the center of the cyclic algebra al used to define it.
algbasis	entity.name.function	algbasis(al): basis of the stored order of the central simple algebra al.
algbasistoalg	entity.name.function	algbasistoalg(al,x): transforms the column vector x on the integral basis of al into an element of al in algebraic form.
algcenter	entity.name.function	algcenter(al): center of the algebra al.
algcentralproj	entity.name.function	algcentralproj(al,z,{maps=0}): projections of the algebra al on the orthogonal central idempotents z[i].
algchar	entity.name.function	algchar(al): characteristic of the algebra al.
algcharpoly	entity.name.function	algcharpoly(al,b,{v='x},{abs=0}): (reduced) characteristic polynomial of b in al, with respect to the variable v.
algdegree	entity.name.function	algdegree(al): degree of the central simple algebra al.
algdep	entity.name.function	algdep(z,k,{flag=0}): algebraic relations up to degree k of z, using lindep([1,z,...,z^(k-1)], flag).
algdim	entity.name.function	algdim(al,{abs=0}): dimension of the algebra al.
algdisc	entity.name.function	algdisc(al): discriminant of the stored order of the algebra al.
algdivl	entity.name.function	algdivl(al,x,y): element x\y in al.
algdivr	entity.name.function	algdivr(al,x,y): element x/y in al.
alggroup	entity.name.function	alggroup(gal, {p=0}): constructs the group algebra of gal over Q (resp. Fp).
alggroupcenter	entity.name.function	alggroupcenter(gal,{p=0},{&cc}): constructs the center of the group algebra of gal over Q (resp. Fp), and sets cc to the conjugacy classes of gal.
alghasse	entity.name.function	alghasse(al,pl): the hasse invariant of the central simple algebra al at the place pl.
alghassef	entity.name.function	alghassef(al): the hasse invariant of the central simple algebra al at finite places.
alghassei	entity.name.function	alghassei(al): the hasse invariant of the central simple algebra al at infinite places.
algindex	entity.name.function	algindex(al,{pl}): the index of the central simple algebra al. If pl is set, it should be a prime ideal of the center or an integer between 1 and r1+r2, and in that case return the local index at the place pl instead.
alginit	entity.name.function	alginit(B, C, {v}, {maxord = 1}): initializes the central simple algebra defined by data B, C. If maxord = 1, compute a maximal order.
alginv	entity.name.function	alginv(al,x): element 1/x in al.
alginvbasis	entity.name.function	alginvbasis(al): basis of the natural order of the central simple algebra al in terms of the stored order.
algisassociative	entity.name.function	algisassociative(mt,p=0): true (1) if the multiplication table mt is suitable for algtableinit(mt,p), false (0) otherwise.
algiscommutative	entity.name.function	algiscommutative(al): test whether the algebra al is commutative.
algisdivision	entity.name.function	algisdivision(al,{pl}): tests whether the central simple algebra al is a division algebra. If pl is set, it should be a prime ideal of the center or an integer between 1 and r1+r2, and in that case tests whether al is locally a division algebra at the place pl instead.
algisdivl	entity.name.function	algisdivl(al,x,y,{&z}): tests whether y is left divisible by x and sets z to the left quotient x\y.
algisinv	entity.name.function	algisinv(al,x,{&ix}): tests whether x is invertible and sets ix to the inverse of x.
algisramified	entity.name.function	algisramified(al,{pl}): tests whether the central simple algebra al is ramified, i.e. not isomorphic to a matrix ring over its center. If pl is set, it should be a prime ideal of the center or an integer between 1 and r1+r2, and in that case tests whether al is locally ramified at the place pl instead.
algissemisimple	entity.name.function	algissemisimple(al): test whether the algebra al is semisimple.
algissimple	entity.name.function	algissimple(al, {ss = 0}): test whether the algebra al is simple.
algissplit	entity.name.function	algissplit(al,{pl}): tests whether the central simple algebra al is split, i.e. isomorphic to a matrix ring over its center. If pl is set, it should be a prime ideal of the center or an integer between 1 and r1+r2, and in that case tests whether al is locally split at the place pl instead.
alglatadd	entity.name.function	alglatadd(al,lat1,lat2,{&ptinter}): the sum of the lattices lat1 and lat2. If ptinter is present, set it to the intersection of the lattices.
alglatcontains	entity.name.function	alglatcontains(al,lat,x,{&ptc}): tests whether the lattice lat contains the element x. If ptc is present, sets it to the coordinates of x on the basis of lat.
alglatelement	entity.name.function	alglatelement(al,lat,c): returns the element of al whose coordinates on the Z-basis of lat are c.
alglathnf	entity.name.function	alglathnf(al,m,{d=0}): the lattice generated by the columns of m, assuming that this lattice contains d times the integral basis of al.
alglatindex	entity.name.function	alglatindex(al,lat1,lat2): the generalized index (lat2:lat1).
alglatinter	entity.name.function	alglatinter(al,lat1,lat2,{&ptsum}): the intersection of the lattices lat1 and lat2. If ptsum is present, sets it to the sum of the lattices.
alglatlefttransporter	entity.name.function	alglatlefttransporter(al,lat1,lat2): the set of x in al such that x*lat1 is contained in lat2.
alglatmul	entity.name.function	alglatmul(al,lat1,lat2): the lattice generated by the products of elements of lat1 and lat2.
alglatrighttransporter	entity.name.function	alglatrighttransporter(al,lat1,lat2): the set of x in al such that lat1*x is contained in lat2.
alglatsubset	entity.name.function	alglatsubset(al,lat1,lat2,{&ptindex}): tests whether lat1 is contained in lat2 and if true and ptindex is present, sets it to the index (lat2:lat1).
algmakeintegral	entity.name.function	algmakeintegral(mt,{maps=0}): computes an integral multiplication table for an isomorphic algebra.
algmul	entity.name.function	algmul(al,x,y): element x*y in al.
algmultable	entity.name.function	algmultable(al): multiplication table of al over its prime subfield.
algneg	entity.name.function	algneg(al,x): element -x in al.
algnorm	entity.name.function	algnorm(al,x,{abs=0}): (reduced) norm of x.
algpoleval	entity.name.function	algpoleval(al,T,b): T in K[X] evaluate T(b) in al.
algpow	entity.name.function	algpow(al,x,n): element x^n in al.
algprimesubalg	entity.name.function	algprimesubalg(al): prime subalgebra of the positive characteristic, semisimple algebra al.
algquotient	entity.name.function	algquotient(al,I,{maps=0}): quotient of the algebra al by the two-sided ideal I.
algradical	entity.name.function	algradical(al): Jacobson radical of the algebra al.
algramifiedplaces	entity.name.function	algramifiedplaces(al): vector of the places of the center of al that ramify in al. Each place is described as an integer between 1 and r1 or as a prime ideal.
algrandom	entity.name.function	algrandom(al,b): random element in al with coefficients in [-b,b].
algrelmultable	entity.name.function	algrelmultable(al): multiplication table of the central simple algebra al over its center.
algsimpledec	entity.name.function	algsimpledec(al,{maps=0}): [J,dec] where J is the Jacobson radical of al and dec is the decomposition into simple algebras of the semisimple algebra al/J.
algsplit	entity.name.function	algsplit(al,{v='x}): computes an isomorphism between al and M_d(F_q).
algsplittingdata	entity.name.function	algsplittingdata(al): data stored in the central simple algebra al to compute a splitting of al over an extension.
algsplittingfield	entity.name.function	algsplittingfield(al): the stored splitting field of the central simple algebra al.
algsqr	entity.name.function	algsqr(al,x): element x^2 in al.
algsub	entity.name.function	algsub(al,x,y): element x-y in al.
algsubalg	entity.name.function	algsubalg(al,B): subalgebra of al with basis B.
algtableinit	entity.name.function	algtableinit(mt, {p=0}): initializes the associative algebra over Q (resp. Fp) defined by the multiplication table mt.
algtensor	entity.name.function	algtensor(al1,al2,{maxord=1}): tensor product of al1 and al2.
algtomatrix	entity.name.function	algtomatrix(al,x,{abs=1}): left multiplication table of x (table algebra or abs=1) or image of x under a splitting of al (CSA and abs=0).
algtrace	entity.name.function	algtrace(al,x,{abs=0}): (reduced) trace of x.
algtype	entity.name.function	algtype(al): type of the algebra al.
alias	entity.name.function	alias(newsym,sym): defines the symbol newsym as an alias for the symbol sym.
allocatemem	keyword.control	allocatemem({s=0}): allocates a new stack of s bytes. doubles the stack if s is omitted.
apply	entity.name.function	apply(f, A): apply function f to each entry in A.
arg	entity.name.function	arg(x): argument of x, such that -pi<arg(x)<=pi.
arity	entity.name.function	arity(C): return the arity of the closure C.
asin	entity.name.function	asin(x): arc sine of x.
asinh	entity.name.function	asinh(x): inverse hyperbolic sine of x.
asympnum	entity.name.function	asympnum(expr,{alpha = 1}): asymptotic expansion of expr assuming it has rational coefficients with reasonable height; alpha is as in limitnum.
asympnumraw	entity.name.function	asympnumraw(expr,N,{alpha = 1}): N+1 first terms of asymptotic expansion of expr as floating point numbers; alpha is as in limitnum.
atan	entity.name.function	atan(x): arc tangent of x.
atanh	entity.name.function	atanh(x): inverse hyperbolic tangent of x.
bernfrac	entity.name.function	bernfrac(n): Bernoulli number B_n, as a rational number.
bernpol	entity.name.function	bernpol(n, {v = 'x}): Bernoulli polynomial B_n, in variable v.
bernreal	entity.name.function	bernreal(n): Bernoulli number B_n, as a real number with the current precision.
bernvec	entity.name.function	bernvec(n): returns a vector containing, as rational numbers, the Bernoulli numbers B_0, B_2, ..., B_{2n}.
besselh1	entity.name.function	besselh1(nu,x): H^1-bessel function of index nu and argument x.
besselh2	entity.name.function	besselh2(nu,x): H^2-bessel function of index nu and argument x.
besseli	entity.name.function	besseli(nu,x): I-bessel function of index nu and argument x.
besselj	entity.name.function	besselj(nu,x): J-bessel function of index nu and argument x.
besseljh	entity.name.function	besseljh(n,x): J-bessel function of index n+1/2 and argument x, where n is a nonnegative integer.
besseljzero	entity.name.function	besseljzero(nu,{k=1}): k-th zero of the J-bessel function of index nu.
besselk	entity.name.function	besselk(nu,x): K-bessel function of index nu and argument x.
besseln	entity.name.function	besseln(nu,x): deprecated alias for bessely.
bessely	entity.name.function	bessely(nu,x): Y-bessel function of index nu and argument x.
besselyzero	entity.name.function	besselyzero(nu,{k=1}): k-th zero of the Y-bessel function of index nu.
bestappr	entity.name.function	bestappr(x, {B}): return a rational approximation to x, whose denominator is limited by B, if present. This function applies to reals, intmods, p-adics, and rationals of course. Otherwise it applies recursively to all components.
bestapprPade	entity.name.function	bestapprPade(x, {B}): returns a rational function approximation to x. This function applies to series, polmods, and rational functions of course. Otherwise it applies recursively to all components.
bestapprnf	entity.name.function	bestapprnf(V,T,{rootT}): T being an integral polynomial and V being a scalar, vector, or matrix, return a reasonable approximation of V with polmods modulo T. The rootT argument, if present, must be an element of polroots(T), i.e. a root of T fixing a complex embedding of Q[x]/(T).
bezout	entity.name.function	bezout(x,y): deprecated alias for gcdext.
bezoutres	entity.name.function	bezoutres(A,B,{v}): deprecated alias for polresultantext.
bigomega	entity.name.function	bigomega(x): number of prime divisors of x, counted with multiplicity.
binary	entity.name.function	binary(x): gives the vector formed by the binary digits of x (x integer).
binomial	entity.name.function	binomial(x,{k}): binomial coefficient x*(x-1)...*(x-k+1)/k! defined for k in Z and any x. If k is omitted and x an integer, return the vector [binomial(x,0),...,binomial(x,x)].
bitand	entity.name.function	bitand(x,y): bitwise "and" of two integers x and y. Negative numbers behave as if modulo big power of 2.
bitneg	entity.name.function	bitneg(x,{n=-1}): bitwise negation of an integers x truncated to n bits. n=-1 means represent infinite sequences of bit 1 as negative numbers. Negative numbers behave as if modulo big power of 2.
bitnegimply	entity.name.function	bitnegimply(x,y): bitwise "negated imply" of two integers x and y, in other words, x BITAND BITNEG(y). Negative numbers behave as if modulo big power of 2.
bitor	entity.name.function	bitor(x,y): bitwise "or" of two integers x and y. Negative numbers behave as if modulo big power of 2.
bitprecision	entity.name.function	bitprecision(x,{n}): if n is present and positive, return x at precision n bits. If n is omitted, return real precision of object x in bits.
bittest	entity.name.function	bittest(x,n): gives bit number n (coefficient of 2^n) of the integer x. Negative numbers behave as if modulo big power of 2.
bitxor	entity.name.function	bitxor(x,y): bitwise "exclusive or" of two integers x and y. Negative numbers behave as if modulo big power of 2.
bnfcertify	entity.name.function	bnfcertify(bnf,{flag = 0}): certify the correctness (i.e. remove the GRH) of the bnf data output by bnfinit. If flag is present, only certify that the class group is a quotient of the one computed in bnf (much simpler in general).
bnfdecodemodule	entity.name.function	bnfdecodemodule(nf,m): given a coded module m as in bnrdisclist, gives the true module.
bnfinit	entity.name.function	bnfinit(P,{flag=0},{tech=[]}): compute the necessary data for future use in ideal and unit group computations, including fundamental units if they are not too large. flag and tech are both optional. flag can be any of 0: default, 1: include all data in algebraic form (compact units). See manual for details about tech.
bnfisintnorm	entity.name.function	bnfisintnorm(bnf,x): compute a complete system of solutions (modulo units of positive norm) of the absolute norm equation N(a)=x, where a belongs to the maximal order of big number field bnf (if bnf is not certified, this depends on GRH).
bnfisnorm	entity.name.function	bnfisnorm(bnf,x,{flag=1}): tries to tell whether x (in Q) is the norm of some fractional y (in bnf). Returns a vector [a,b] where x=Norm(a)*b. Looks for a solution which is a S-unit, with S a certain list of primes (in bnf) containing (among others) all primes dividing x. If bnf is known to be Galois, you may set flag=0 (in this case, x is a norm iff b=1). If flag is nonzero the program adds to S all the primes: dividing flag if flag<0, or less than flag if flag>0. The answer is guaranteed (i.e x norm iff b=1) under GRH, if S contains all primes less than 12.log(disc(Bnf))^2, where Bnf is the Galois closure of bnf.
bnfisprincipal	entity.name.function	bnfisprincipal(bnf,x,{flag=1}): bnf being output by bnfinit, gives [e,t], where e is the vector of exponents on the class group generators and t is the generator of the resulting principal ideal. In particular x is principal if and only if e is the zero vector. flag is optional, whose binary digits mean 1: output [e,t] (only e if unset); 2: increase precision until t can be computed (do not insist if unset); 4: return t in factored form (compact representation).
bnfissunit	entity.name.function	bnfissunit(bnf,sfu,x): this function is obsolete, use bnfisunit.
bnfisunit	entity.name.function	bnfisunit(bnf,x, {U}): bnf being output by bnfinit, give the column vector of exponents of x on the fundamental units and the roots of unity if x is a unit, the empty vector otherwise. If U is present, as given by bnfunits, decompose x on the attached S-units generators.
bnflog	entity.name.function	bnflog(bnf, l): let bnf be attached to a number field F and let l be a prime number. Return the logarithmic l-class group Cl~_F.
bnflogdegree	entity.name.function	bnflogdegree(nf, A, l): let A be an ideal, return exp(deg_F A) the exponential of the l-adic logarithmic degree.
bnflogef	entity.name.function	bnflogef(nf,pr): return [e~, f~] the logarithmic ramification and residue degrees for the maximal ideal pr.
bnfnarrow	entity.name.function	bnfnarrow(bnf): given a big number field as output by bnfinit, gives as a 3-component vector the structure of the narrow class group.
bnfsignunit	entity.name.function	bnfsignunit(bnf): matrix of signs of the real embeddings of the system of fundamental units found by bnfinit.
bnfsunit	entity.name.function	bnfsunit(bnf,S): compute the fundamental S-units of the number field bnf output by bnfinit, S being a list of prime ideals. res[1] contains the S-units, res[5] the S-classgroup.
bnfunits	entity.name.function	bnfunits(bnf,{S}): return the fundamental units of the number field bnf output by bnfinit; if S is present and is a list of prime ideals, compute fundamental S-units instead. The first component of the result contains the S-units, followed by fundamental units, followed by the torsion unit. The result may be used as an optional argument to bnfisunit.
bnrL1	entity.name.function	bnrL1(bnr, {H}, {flag=0}): bnr being output by bnrinit and H being a square matrix defining a congruence subgroup of bnr (the trivial subgroup if omitted), for each character of bnr trivial on this subgroup, compute L(1, chi) (or equivalently the first nonzero term c(chi) of the expansion at s = 0). The binary digits of flag mean 1: if 0 then compute the term c(chi) and return [r(chi), c(chi)] where r(chi) is the order of L(s, chi) at s = 0, or if 1 then compute the value at s = 1 (and in this case, only for nontrivial characters), 2: if 0 then compute the value of the primitive L-function attached to chi, if 1 then compute the value of the L-function L_S(s, chi) where S is the set of places dividing the modulus of bnr (and the infinite places), 3: return also the characters.
bnrchar	entity.name.function	bnrchar(G,g,{v}): returns all characters chi on G such that chi(g[i]) = e(v[i]); if v is omitted, returns all characters that are trivial on the g[i].
bnrclassfield	entity.name.function	bnrclassfield(bnr,{subgp},{flag=0}): bnr being as output by bnrinit, find a relative equation for the class field corresponding to the congruence subgroup described by (bnr,subgp). If flag=0, return a vector of polynomials such that the compositum of the corresponding fields is the class field; if flag=1 return a single relative polynomial; if flag=2 return a single absolute polynomial.
bnrclassno	entity.name.function	bnrclassno(A,{B},{C}): relative degree of the class field defined by A,B,C. [A,{B},{C}] is of type [bnr], [bnr,subgroup], [bnf,modulus], or [bnf,modulus,subgroup]. Faster than bnrinit if only the ray class number is wanted.
bnrclassnolist	entity.name.function	bnrclassnolist(bnf,list): if list is as output by ideallist or similar, gives list of corresponding ray class numbers.
bnrcompositum	entity.name.function	bnrcompositum(A,B): compositum [bnr,H] of the two abelian extensions given by A = [bnr1,H1] and B = [bnr2,H2], where bnr1 and bnr2 are attached to the same base field.
bnrconductor	entity.name.function	bnrconductor(A,{B},{C},{flag=0}): conductor f of the subfield of the ray class field given by A,B,C. flag is optional and can be 0: default, 1: returns [f, Cl_f, H], H subgroup of the ray class group modulo f defining the extension, 2: returns [f, bnr(f), H].
bnrconductorofchar	entity.name.function	bnrconductorofchar(bnr,chi): this function is obsolete, use bnrconductor.
bnrdisc	entity.name.function	bnrdisc(A,{B},{C},{flag=0}): absolute or relative [N,R1,discf] of the field defined by A,B,C. [A,{B},{C}] is of type [bnr], [bnr,subgroup], [bnf, modulus] or [bnf,modulus,subgroup], where bnf is as output by bnfinit, bnr by bnrinit, and subgroup is the HNF matrix of a subgroup of the corresponding ray class group (if omitted, the trivial subgroup). flag is optional whose binary digits mean 1: give relative data; 2: return 0 if modulus is not the conductor.
bnrdisclist	entity.name.function	bnrdisclist(bnf,bound,{arch}): list of discriminants of ray class fields of all conductors up to norm bound. The ramified Archimedean places are given by arch; all possible values are taken if arch is omitted. Supports the alternative syntax bnrdisclist(bnf,list), where list is as output by ideallist or ideallistarch (with units).
bnrgaloisapply	entity.name.function	bnrgaloisapply(bnr, mat, H): apply the automorphism given by its matrix mat to the congruence subgroup H given as a HNF matrix. The matrix mat can be computed with bnrgaloismatrix.
bnrgaloismatrix	entity.name.function	bnrgaloismatrix(bnr,aut): return the matrix of the action of the automorphism aut of the base field bnf.nf on the generators of the ray class field bnr.gen; aut can be given as a polynomial, or a vector of automorphisms or a galois group as output by galoisinit, in which case a vector of matrices is returned (in the later case, only for the generators aut.gen).
bnrinit	entity.name.function	bnrinit(bnf,f,{flag=0},{cycmod}): given a bnf as output by bnfinit and a modulus f, initializes data linked to the ray class group structure corresponding to this module. flag is optional, and can be 0: default, 1: compute also the generators. If the positive integer cycmod is present, only compute the ray class group modulo cycmod-th powers.
bnrisconductor	entity.name.function	bnrisconductor(A,{B},{C}): returns 1 if the modulus is the conductor of the subfield of the ray class field given by A,B,C (see bnrdisc), and 0 otherwise. Slightly faster than bnrconductor if this is the only desired result.
bnrisgalois	entity.name.function	bnrisgalois(bnr, gal, H): check whether the class field attached to the subgroup H is Galois over the subfield of bnr.nf fixed by the Galois group gal, which can be given as output by galoisinit, or as a matrix or a vector of matrices as output by bnrgaloismatrix. The ray class field attached to bnr need to be Galois, which is not checked.
bnrisprincipal	entity.name.function	bnrisprincipal(bnr,x,{flag=1}): bnr being output by bnrinit and x being an ideal coprime to bnr.mod, returns [v,alpha], where v is the vector of exponents on the ray class group generators and alpha is the generator of the resulting principal ideal. If (optional) flag is set to 0, output only v.
bnrmap	entity.name.function	bnrmap(A, B): if A and B are bnr structures for the same bnf attached to moduli mA and mB with mB | mA, return the canonical surjection from A to B. Alternatively, if A is a map from bnrmap and B is a congruence subgroup or ray class character modulo mA, return the corresponding object on Cl(mB).
bnrrootnumber	entity.name.function	bnrrootnumber(bnr,chi,{flag=0}): returns the so-called Artin Root Number, i.e. the constant W appearing in the functional equation of the Hecke L-function attached to chi. Set flag = 1 if the character is known to be primitive.
bnrstark	entity.name.function	bnrstark(bnr,{subgroup}): bnr being as output by bnrinit, finds a relative equation for the class field corresponding to the module in bnr and the given congruence subgroup (the trivial subgroup if omitted) using Stark's units. The ground field and the class field must be totally real.
break	keyword.control	break({n=1}): interrupt execution of current instruction sequence, and exit from the n innermost enclosing loops.
breakpoint	keyword.control	breakpoint(): interrupt the program and enter the breakloop. The program continues when the breakloop is exited.
call	entity.name.function	call(f, A): A being a vector, evaluates f(A[1],...,A[#A]).
ceil	entity.name.function	ceil(x): ceiling of x = smallest integer >= x.
centerlift	entity.name.function	centerlift(x,{v}): centered lift of x. Same as lift except for intmod and padic components.
characteristic	entity.name.function	characteristic(x): characteristic of the base ring over which x is defined.
charconj	entity.name.function	charconj(cyc,chi): given a finite abelian group (by its elementary divisors cyc) and a character chi, return the conjugate character.
chardiv	entity.name.function	chardiv(cyc, a,b): given a finite abelian group (by its elementary divisors cyc) and two characters a and b, return the character a/b.
chareval	entity.name.function	chareval(G, chi, x, {z}): given an abelian group structure affording a discrete logarithm method, e.g. G = znstar(N,1) or a bnr structure, let x be an element of G and let chi be a character of G. This function returns the value of chi at x, where the encoding depends on the optional argument z; if z is omitted, we fix a canonical o-th root of 1, zeta_o, where o is the character order and return the rational number c/o where chi(x) = (zeta_o)^c.
chargalois	entity.name.function	chargalois(cyc,{ORD}): let cyc represent a finite abelian group G by its elementary divisors cyc, return a list of representatives for the Galois orbits of characters of G. If ORD is present, select characters depending on their orders: if ORD is a t_INT, restrict to orders less than this bound; if ORD is a t_VEC or t_VECSMALL, restrict to orders in the list.
charker	entity.name.function	charker(cyc,chi): given a finite abelian group (by its elementary divisors cyc) and a character chi, return its kernel.
charmul	entity.name.function	charmul(cyc, a,b): given a finite abelian group (by its elementary divisors cyc) and two characters a and b, return the product character ab.
charorder	entity.name.function	charorder(cyc,chi): given a finite abelian group (by its elementary divisors cyc) and a character chi, return the order of chi.
charpoly	entity.name.function	charpoly(A,{v='x},{flag=5}): det(v*Id-A)=characteristic polynomial of the matrix or polmod A. flag is optional and ignored unless A is a matrix; it may be set to 0 (Le Verrier), 1 (Lagrange interpolation), 2 (Hessenberg form), 3 (Berkowitz), 4 (modular) if A is integral, or 5 (default, choose best method). Algorithms 0 (Le Verrier) and 1 (Lagrange) assume that n! is invertible, where n is the dimension of the matrix.
charpow	entity.name.function	charpow(cyc, a,n): given a finite abelian group (by its elementary divisors cyc) a character a and an integer n return the character a^n.
chinese	entity.name.function	chinese(x,{y}): x,y being both intmods (or polmods) computes z in the same residue classes as x and y.
cmp	entity.name.function	cmp(x,y): compare two arbitrary objects x and y (1 if x>y, 0 if x=y, -1 if x<y). The function is used to implement sets, and has no useful mathematical meaning.
component	entity.name.function	component(x,n): the n'th component of the internal representation of x. For vectors or matrices, it is simpler to use x[]. For list objects such as nf, bnf, bnr or ell, it is much easier to use member functions starting with ".".
concat	entity.name.function	concat(x,{y}): concatenation of x and y, which can be scalars, vectors or matrices, or lists (in this last case, both x and y have to be lists). If y is omitted, x has to be a list or row vector and its elements are concatenated.
conj	entity.name.function	conj(x): the algebraic conjugate of x.
conjvec	entity.name.function	conjvec(z): conjugate vector of the algebraic number z.
content	entity.name.function	content(x,{D}): gcd of all the components of x, when this makes sense.
contfrac	entity.name.function	contfrac(x,{b},{nmax}): continued fraction expansion of x (x rational,real or rational function). b and nmax are both optional, where b is the vector of numerators of the continued fraction, and nmax is a bound for the number of terms in the continued fraction expansion.
contfraceval	entity.name.function	contfraceval(CF,t,{lim=-1}): given a continued fraction CF from contfracinit, evaluate the first lim terms of the continued fraction at t (all terms if lim is negative or omitted).
contfracinit	entity.name.function	contfracinit(M,{lim = -1}): given M representing the power series S = sum_{n>=0} M[n+1]z^n, transform it into a continued fraction suitable for evaluation.
contfracpnqn	entity.name.function	contfracpnqn(x, {n=-1}): [p_n,p_{n-1}; q_n,q_{n-1}] corresponding to the continued fraction x. If n >= 0 is present, returns all convergents from p_0/q_0 up to p_n/q_n.
core	entity.name.function	core(n,{flag=0}): unique squarefree integer d dividing n such that n/d is a square. If (optional) flag is nonzero, output the two-component row vector [d,f], where d is the unique squarefree integer dividing n such that n/d=f^2 is a square.
coredisc	entity.name.function	coredisc(n,{flag=0}): discriminant of the quadratic field Q(sqrt(n)). If (optional) flag is nonzero, output a two-component row vector [d,f], where d is the discriminant of the quadratic field Q(sqrt(n)) and n=df^2. f may be a half integer.
cos	entity.name.function	cos(x): cosine of x.
cosh	entity.name.function	cosh(x): hyperbolic cosine of x.
cotan	entity.name.function	cotan(x): cotangent of x.
cotanh	entity.name.function	cotanh(x): hyperbolic cotangent of x.
dbg_down	keyword.control	dbg_down({n=1}): (break loop) go down n frames. Cancel a previous dbg_up.
dbg_err	entity.name.function	dbg_err(): (break loop) return the error data of the current error, if any.
dbg_up	keyword.control	dbg_up({n=1}): (break loop) go up n frames, which allows to inspect data of the parent function.
dbg_x	entity.name.function	dbg_x(A,{n}): print inner structure of A, complete if n is omitted, up to level n otherwise. Intended for debugging.
default	keyword.control	default({key},{val}): returns the current value of the default key. If val is present, set opt to val first. If no argument is given, print a list of all defaults as well as their values.
denominator	entity.name.function	denominator(f,{D}): denominator of f.
deriv	entity.name.function	deriv(x,{v}): derivative of x with respect to v, or to the main variable of x if v is omitted.
derivn	entity.name.function	derivn(x,n,{v}): n-th derivative of x with respect to v, or to the main variable of x if v is omitted.
derivnum	keyword.control	derivnum(X=a,expr,{ind=1}): numerical derivation of expr with respect to X at X = a. The order of derivation is given by parameter 'ind', which can be a vector.
diffop	entity.name.function	diffop(x,v,d,{n=1}): apply the differential operator D to x, where D is defined by D(v[i])=d[i], where v is a vector of variable names. D is 0 for variables outside of v unless they appear as modulus of a POLMOD. If the optional parameter n is given, return D^n(x) instead.
digits	entity.name.function	digits(x,{b}): gives the vector formed by the digits of x in base b.
dilog	entity.name.function	dilog(x): dilogarithm of x.
dirdiv	entity.name.function	dirdiv(x,y): division of the Dirichlet series x by the Dirichlet series y.
direuler	keyword.control	direuler(p=a,b,expr,{c}): Dirichlet Euler product of expression expr from p=a to p=b, limited to b terms. Expr should be a polynomial or rational function in p and X, and X is understood to mean p^(-s). If c is present, output only the first c terms.
dirmul	entity.name.function	dirmul(x,y): multiplication of the Dirichlet series x by the Dirichlet series y.
dirpowers	entity.name.function	dirpowers(n,x): return the vector [1^x,2^x,...,n^x].
dirpowerssum	entity.name.function	dirpowerssum(N,x,{f}): return f(1)1^x + f(2)2^x + ... + f(N)N^x, where f is a completely multiplicative function (= 1 if omitted)
dirzetak	entity.name.function	dirzetak(nf,b): Dirichlet series of the Dedekind zeta function of the number field nf up to the bound b-1.
divisors	entity.name.function	divisors(x,{flag=0}): gives a vector formed by the divisors of x in increasing order. If flag = 1, return pairs [d, factor(d)].
divisorslenstra	entity.name.function	divisorslenstra(N, r, s): finds all divisors d of N such that d = r (mod s). Assume that (r,s) = 1 and s^3 > N.
divrem	entity.name.function	divrem(x,y,{v}): euclidean division of x by y giving as a 2-dimensional column vector the quotient and the remainder, with respect to v (to main variable if v is omitted).
eint1	entity.name.function	eint1(x,{n}): exponential integral E1(x). If n is present and x > 0, computes the vector of the first n values of the exponential integral E1(n x).
ell2cover	entity.name.function	ell2cover(E): if E is an elliptic curve over Q, return a basis of the set of everywhere locally soluble 2-covers of the curve E. For each cover a pair [R,P] is returned where y^2-R(x) is a quartic curve and P belongs to E(k), where k = Q(x)[y] / (y^2-R(x)).
ellE	entity.name.function	ellE(k): Complete elliptic integral of the second kind for the complex parameter k using the agm.
ellK	entity.name.function	ellK(k): Complete elliptic integral of the first kind for the complex parameter k using the agm.
ellL1	entity.name.function	ellL1(E, {r = 0}): returns the value at s=1 of the derivative of order r of the L-function of the elliptic curve E.
elladd	entity.name.function	elladd(E,z1,z2): sum of the points z1 and z2 on elliptic curve E.
ellak	entity.name.function	ellak(E,n): computes the n-th Fourier coefficient of the L-function of the elliptic curve E (assumes E is an integral model).
ellan	entity.name.function	ellan(E,n): computes the first n Fourier coefficients of the L-function of the elliptic curve E defined over a number field (n<2^24 on a 32-bit machine).
ellanalyticrank	entity.name.function	ellanalyticrank(E, {eps}): returns the order of vanishing at s=1 of the L-function of the elliptic curve E and the value of the first nonzero derivative. To determine this order, it is assumed that any value less than eps is zero. If no value of eps is given, 2^(-bitprecision/2) is used.
ellap	entity.name.function	ellap(E,{p}): given an elliptic curve E defined over a finite field Fq, return the trace of Frobenius a_p = q+1-#E(Fq); for other fields of definition K, p must define a finite residue field, (p prime for K = Qp or Q; p a maximal ideal for K a number field), return the order of the (nonsingular) reduction of E.
ellbil	entity.name.function	ellbil(E,z1,z2): deprecated alias for ellheight(E,P,Q).
ellbsd	entity.name.function	ellbsd(E): E being an elliptic curve over a number field, returns a real number c such that the BSD conjecture predicts that lfun(E,1,r)/r! = c*R*S where r is the rank, R is the regulator and S is the cardinal of the Tate-Shafarevich group.
ellcard	entity.name.function	ellcard(E,{p}): given an elliptic curve E defined over a finite field Fq, return the order of the group E(Fq); for other fields of definition K, p must define a finite residue field, (p prime for K = Qp or Q; p a maximal ideal for K a number field), return the order of the (nonsingular) reduction of E.
ellchangecurve	entity.name.function	ellchangecurve(E,v): change data on elliptic curve according to v=[u,r,s,t].
ellchangepoint	entity.name.function	ellchangepoint(x,v): change data on point or vector of points x on an elliptic curve according to v=[u,r,s,t].
ellchangepointinv	entity.name.function	ellchangepointinv(x,v): change data on point or vector of points x on an elliptic curve according to v=[u,r,s,t], inverse of ellchangepoint.
ellconvertname	entity.name.function	ellconvertname(name): convert an elliptic curve name (as found in the elldata database) from a string to a triplet [conductor, isogeny class, index]. It will also convert a triplet back to a curve name.
elldivpol	entity.name.function	elldivpol(E,n,{v='x}): n-division polynomial f_n for the curve E in the variable v.
elleisnum	entity.name.function	elleisnum(w,k,{flag=0}): k being an even positive integer, computes the numerical value of the Eisenstein series of weight k at the lattice w, as given by ellperiods. When flag is nonzero and k=4 or 6, this gives the elliptic invariants g2 or g3 with the correct normalization.
elleta	entity.name.function	elleta(w): w=[w1,w2], returns the vector [eta1,eta2] of quasi-periods attached to [w1,w2].
ellformaldifferential	entity.name.function	ellformaldifferential(E, {n=seriesprecision}, {t = 'x}) : E elliptic curve, n integer. Returns n terms of the power series [f, g] such that omega = dx/(2y+a_1x+a_3) = f(t) dt and eta = x(t) * omega = g(t) dt in the local parameter t=-x/y.
ellformalexp	entity.name.function	ellformalexp(E, {n = seriesprecision}, {z = 'x}) : E elliptic curve, returns n terms of the formal elliptic exponential on E as a series in z.
ellformallog	entity.name.function	ellformallog(E, {n = seriesprecision}, {v = 'x}): E elliptic curve, returns n terms of the elliptic logarithm as a series of t =-x/y.
ellformalpoint	entity.name.function	ellformalpoint(E, {n = seriesprecision}, {v = 'x}): E elliptic curve, n integer; return the coordinates [x(t), y(t)] on the elliptic curve as a formal expansion in the formal parameter t = -x/y.
ellformalw	entity.name.function	ellformalw(E, {n = seriesprecision}, {t = 'x}): E elliptic curve, n integer; returns n terms of the formal expansion of w = -1/y in the formal parameter t = -x/y.
ellfromeqn	entity.name.function	ellfromeqn(P): given a genus 1 plane curve, defined by the affine equation f(x,y) = 0, return the coefficients [a1,a2,a3,a4,a6] of a Weierstrass equation for its Jacobian. This allows to recover a Weierstrass model for an elliptic curve given by a general plane cubic or by a binary quartic or biquadratic model.
ellfromj	entity.name.function	ellfromj(j): returns the coefficients [a1,a2,a3,a4,a6] of a fixed elliptic curve with j-invariant j.
ellgenerators	entity.name.function	ellgenerators(E): if E is an elliptic curve over the rationals, return the generators of the Mordell-Weil group attached to the curve. This relies on the curve being referenced in the elldata database. If E is an elliptic curve over a finite field Fq as output by ellinit(), return a minimal set of generators for the group E(Fq).
ellglobalred	entity.name.function	ellglobalred(E): E being an elliptic curve over a number field, returns [N, v, c, faN, L], where N is the conductor of E, c is the product of the local Tamagawa numbers c_p, faN is the factorization of N and L[i] is elllocalred(E, faN[i,1]); v is an obsolete field.
ellgroup	entity.name.function	ellgroup(E,{p},{flag}): given an elliptic curve E defined over a finite field Fq, return the structure of the group E(Fq); for other fields of definition K, p must define a finite residue field (p prime for K = Qp or Q; p a maximal ideal for K a number field) and we return the structure of the (nonsingular) reduction of E. If flag is 1, return also generators, the curve equation must be minimal at p.
ellheegner	entity.name.function	ellheegner(E): return a rational nontorsion point on the elliptic curve E assumed to be of rank 1.
ellheight	entity.name.function	ellheight(E,{P},{Q}): Faltings height of the curve E, resp. canonical height of the point P on elliptic curve E, resp. the value of the attached bilinear form at (P,Q).
ellheightmatrix	entity.name.function	ellheightmatrix(E,x): gives the height matrix for vector of points x on elliptic curve E.
ellidentify	entity.name.function	ellidentify(E): look up the elliptic curve E in the elldata database and return [[N, M, ...], C] where N is the name of the curve in Cremona's database, M the minimal model and C the change of coordinates (see ellchangecurve).
ellinit	entity.name.function	ellinit(x,{D=1}): let x be a vector [a1,a2,a3,a4,a6], or [a4,a6] if a1=a2=a3=0, defining the curve Y^2 + a1.XY + a3.Y = X^3 + a2.X^2 + a4.X + a6; x can also be a string, in which case the curve with matching name is retrieved from the elldata database, if available. This function initializes an elliptic curve over the domain D (inferred from coefficients if omitted).
ellintegralmodel	entity.name.function	ellintegralmodel(E,{&v}): given an elliptic curve E defined over a number field or Qp, returns an integral model. If v is present, sets the variable v to the corresponding change of variable.
ellisdivisible	entity.name.function	ellisdivisible(E,P,n,{&Q}): given E/K and P in E(K), checks whether P = [n]R for some R in E(K) and sets Q to one such R if so; the integer n >= 0 may be given as ellxn(E,n).
ellisogeny	entity.name.function	ellisogeny(E, G, {only_image = 0}, {x = 'x}, {y = 'y}): compute the image and isogeny corresponding to the quotient of E by the subgroup G.
ellisogenyapply	entity.name.function	ellisogenyapply(f, g): given an isogeny f and g either a point P (in the domain of f) or an isogeny, apply f to g: return the image of P under f or the composite isogeny f o g.
ellisomat	entity.name.function	ellisomat(E, {p=0}, {fl=0}): E being an elliptic curve over a number field K, return a list of representatives of the isomorphism classes of elliptic curves defined over K and K-isogenous to E, with the corresponding isogenies from E and their dual, and the matrix of the isogeny degrees between the curves. If the flag fl is 1, the isogenies are not computed, which saves time. If p is set, it must be a prime number: in this case only isogenies of degree a power of p are considered.
ellisoncurve	entity.name.function	ellisoncurve(E,z): true(1) if z is on elliptic curve E, false(0) if not.
ellisotree	entity.name.function	ellisotree(E): E being an elliptic curve over Q or a set of isogenous rational curves as given by ellisomat, return minimal models of the isomorphism classes of elliptic curves isogenous to E (or in the set) and the oriented graph of isogenies of prime degree (adjacency matrix).
ellissupersingular	entity.name.function	ellissupersingular(E,{p}): return 1 if the elliptic curve E, defined over a number field or a finite field, is supersingular at p, and 0 otherwise.
ellj	entity.name.function	ellj(x): elliptic j invariant of x.
elllocalred	entity.name.function	elllocalred(E,{p}): E being an elliptic curve, returns [f,kod,[u,r,s,t],c], where f is the conductor's exponent, kod is the Kodaira type for E at p, [u,r,s,t] is the change of variable needed to make E minimal at p, and c is the local Tamagawa number c_p.
elllog	entity.name.function	elllog(E,P,G,{o}): return the discrete logarithm of the point P of the elliptic curve E in base G. If present, o represents the order of G. If not present, assume that G generates the curve.
elllseries	entity.name.function	elllseries(E,s,{A=1}): L-series at s of the elliptic curve E, where A a cut-off point close to 1.
ellminimaldisc	entity.name.function	ellminimaldisc(E): E being an elliptic curve defined over a number field output by ellinit, return the minimal discriminant ideal of E.
ellminimalmodel	entity.name.function	ellminimalmodel(E,{&v}): determines whether the elliptic curve E defined over a number field admits a global minimal model. If so return it and sets v to the corresponding change of variable. Else return the (nonprincipal) Weierstrass class of E.
ellminimaltwist	entity.name.function	ellminimaltwist(E, {flag=0}): E being an elliptic curve defined over Q, return a discriminant D such that the twist of E by D is minimal among all possible quadratic twists, i.e., if flag=0, its minimal model has minimal discriminant, or if flag=1, it has minimal conductor.
ellmoddegree	entity.name.function	ellmoddegree(e): e being an elliptic curve defined over Q output by ellinit, compute the modular degree of e divided by the square of the Manin constant.
ellmodulareqn	entity.name.function	ellmodulareqn(N,{x},{y}): given a prime N < 500, return a vector [P, t] where P(x,y) is a modular equation of level N. This requires the package seadata. The equation is either of canonical type (t=0) or of Atkin type (t=1).
ellmul	entity.name.function	ellmul(E,z,n): n times the point z on elliptic curve E (n in Z).
ellneg	entity.name.function	ellneg(E,z): opposite of the point z on elliptic curve E.
ellnonsingularmultiple	entity.name.function	ellnonsingularmultiple(E,P): given E/Q and P in E(Q), returns the pair [R,n] where n is the least positive integer such that R = [n]P has everywhere good reduction. More precisely, its image in a minimal model is everywhere nonsingular.
ellorder	entity.name.function	ellorder(E,z,{o}): order of the point z on the elliptic curve E over a number field or a finite field, 0 if nontorsion. The parameter o, if present, represents a nonzero multiple of the order of z.
ellordinate	entity.name.function	ellordinate(E,x): y-coordinates corresponding to x-ordinate x on elliptic curve E.
ellpadicL	entity.name.function	ellpadicL(E, p, n, {s = 0}, {r = 0}, {D = 1}): returns the value on a character of Z_p^* represented by an integer s or a vector [s1,s2] of the derivative of order r of the p-adic L-function of the elliptic curve E (twisted by D, if present).
ellpadicbsd	entity.name.function	ellpadicbsd(E, p, n, {D = 1}): returns [r,Lp] where r is the (conjectural) analytic rank of the p-adic L-function attached to the quadratic twist E_D and Lp is (conjecturally) equal to the product of the p-adic regulator and the cardinal of the Tate-Shafarevich group.
ellpadicfrobenius	entity.name.function	ellpadicfrobenius(E,p,n): matrix of the Frobenius at p>2 in the standard basis of H^1_dR(E) to absolute p-adic precision p^n.
ellpadicheight	entity.name.function	ellpadicheight(E,p,n, P,{Q}): E elliptic curve/Q, P in E(Q), p prime, n an integer; returns the cyclotomic p-adic heights of P. Resp. the value of the attached bilinear form at (P,Q).
ellpadicheightmatrix	entity.name.function	ellpadicheightmatrix(E,p,n,Q): gives the height-pairing matrix for vector of points Q on elliptic curve E.
ellpadiclambdamu	entity.name.function	ellpadiclambdamu(E, p, {D=1},{i=0}): returns the Iwasawa invariants for the p-adic L-function attached to E, twisted by (D,.) and the i-th power of the Teichmuller character.
ellpadiclog	entity.name.function	ellpadiclog(E,p,n,P): returns the logarithm of P (in the kernel of reduction) to relative p-adic precision p^n.
ellpadicregulator	entity.name.function	ellpadicregulator(E,p,n,S): E elliptic curve/Q, S a vector of points in E(Q), p prime, n an integer; returns the p-adic cyclotomic regulator of the points of S at precision p^n.
ellpadics2	entity.name.function	ellpadics2(E,p,n): returns s2 to absolute p-adic precision p^n.
ellperiods	entity.name.function	ellperiods(w, {flag = 0}): w describes a complex period lattice ([w1,w2] or an ellinit structure). Returns normalized periods [W1,W2] generating the same lattice such that tau := W1/W2 satisfies Im(tau) > 0 and lies in the standard fundamental domain for SL2. If flag is 1, the return value is [[W1,W2], [e1,e2]], where e1, e2 are the quasi-periods attached to [W1,W2], satisfying e2 W1 - e1 W2 = 2 Pi I.
ellpointtoz	entity.name.function	ellpointtoz(E,P): lattice point z corresponding to the point P on the elliptic curve E.
ellpow	entity.name.function	ellpow(E,z,n): deprecated alias for ellmul.
ellrank	entity.name.function	ellrank(E,{effort=0},{points}): if E is an elliptic curve over Q, attempt to compute the Mordell-Weil group attached to the curve. The output is [r,R,s,L] such that the rank is between r and R (both included), s gives informations on the Tate-Shafarevich group, and L is a list of independent, non-torsion rational points on the curve. E can also be given as the output of ellrankinit(E).
ellrankinit	entity.name.function	ellrankinit(E): if E is an elliptic curve over Q, initialize data for further calls to ellrank.
ellratpoints	entity.name.function	ellratpoints(E,h,{flag=0}): E being an rational model of an elliptic curve, return a vector containing the affine rational points on the curve of naive height less than h. If fl=1, stop as soon as a point is found.
ellrootno	entity.name.function	ellrootno(E,{p}): root number for the L-function of the elliptic curve E/Q at a prime p (including 0, for the infinite place); global root number if p is omitted. If p is omitted, the curve can also be defined over a number field.
ellsaturation	entity.name.function	ellsaturation(E, V, B): let E be an elliptic curve over Q and V be a vector of independent rational points on E of infinite order that generate a subgroup G of E(Q) of finite index. Return a new set W of the same length that generate a subgroup H of E(Q) containing G and such that [E(Q):H] is not divisible by any prime number less than B.
ellsea	entity.name.function	ellsea(E,{tors=0}): computes the order of the group E(Fq) for the elliptic curve E, defined over a finite field, using SEA algorithm, with early abort for curves (or their quadratic twist) with nonprime order.
ellsearch	entity.name.function	ellsearch(N): returns all curves in the elldata database matching constraint N: given name (N = "11a1" or [11,0,1]), given isogeny class (N = "11a" or [11,0]), or given conductor (N = 11, "11", or [11]).
ellsigma	entity.name.function	ellsigma(L,{z='x},{flag=0}): computes the value at z of the Weierstrass sigma function attached to the lattice L, as given by ellperiods(,1). If flag = 1, returns an arbitrary determination of the logarithm of sigma.
ellsub	entity.name.function	ellsub(E,z1,z2): difference of the points z1 and z2 on elliptic curve E.
elltamagawa	entity.name.function	elltamagawa(E): E being an elliptic curve over a number field, returns the global Tamagawa number of the curve.
elltaniyama	entity.name.function	elltaniyama(E, {n = seriesprecision}): modular parametrization of elliptic curve E/Q.
elltatepairing	entity.name.function	elltatepairing(E, P, Q, m): computes the Tate pairing of the two points P and Q on the elliptic curve E. The point P must be of m-torsion.
elltors	entity.name.function	elltors(E): torsion subgroup of elliptic curve E: order, structure, generators.
elltrace	entity.name.function	elltrace(E,P): sum of the Galois conjugates of the point P on elliptic curve E.
elltwist	entity.name.function	elltwist(E,{P}): returns an ell structure for the twist of the elliptic curve E by the quadratic extension defined by P (when P is a polynomial of degree 2) or quadpoly(P) (when P is an integer). If E is defined over a finite field, then P can be omitted.
ellweilcurve	entity.name.function	ellweilcurve(E, {&ms}): let E be an elliptic curve over Q given by ellinit or a rational isogeny class given by ellisomat. Return a list of isomorphism classes of elliptic curves isogenous to E as given by ellisomat and the list of the Smith invariants of the lattice associated to E in H^1(E,Q) in the lattice associated to the modular form. If ms is present, it contains the output of msfromell(Emin,0) where Emin is the list of minimal models attached to the curves in the isogeny class.
ellweilpairing	entity.name.function	ellweilpairing(E, P, Q, m): computes the Weil pairing of the two points of m-torsion P and Q on the elliptic curve E.
ellwp	entity.name.function	ellwp(w,{z='x},{flag=0}): computes the value at z of the Weierstrass P function attached to the lattice w, as given by ellperiods. Optional flag means 0 (default), compute only P(z), 1 compute [P(z),P'(z)].
ellxn	entity.name.function	ellxn(E,n,{v='x}): return polynomials [A,B] in the variable v such that x([n]P) = (A/B)(t) for any P = [t,u] on E outside of n-torsion.
ellzeta	entity.name.function	ellzeta(w,{z='x}): computes the value at z of the Weierstrass Zeta function attached to the lattice w, as given by ellperiods(,1).
ellztopoint	entity.name.function	ellztopoint(E,z): inverse of ellpointtoz. Returns the coordinates of point P on the curve E corresponding to a complex or p-adic z.
erfc	entity.name.function	erfc(x): complementary error function.
errname	entity.name.function	errname(E): returns the type of the error message E.
error	keyword.control	error({str}*): abort script with error message str.
eta	entity.name.function	eta(z,{flag=0}): if flag=0, returns prod(n=1,oo, 1-q^n), where q = exp(2 i Pi z) if z is a complex scalar (belonging to the upper half plane); q = z if z is a p-adic number or can be converted to a power series. If flag is nonzero, the function only applies to complex scalars and returns the true eta function, with the factor q^(1/24) included.
eulerfrac	entity.name.function	eulerfrac(n): Euler number E_n, as a rational number.
eulerianpol	entity.name.function	eulerianpol(n, {v = 'x}): Eulerian polynomial A_n, in variable v.
eulerphi	entity.name.function	eulerphi(x): Euler's totient function of x.
eulerpol	entity.name.function	eulerpol(n, {v = 'x}): Euler polynomial E_n, in variable v.
eulerreal	entity.name.function	eulerreal(n): Euler number E_n, as a real number.
eulervec	entity.name.function	eulervec(n): returns a vector containing the nonzero Euler numbers E_0, E_2, ..., E_{2n}.
eval	entity.name.function	eval(x): evaluation of x, replacing variables by their value.
exp	entity.name.function	exp(x): exponential of x.
expm1	entity.name.function	expm1(x): exp(x)-1.
exponent	entity.name.function	exponent(x): binary exponent of x
export	keyword.control	export(x{=...},...,z{=...}): export the variables x,...,z to the parallel world.
exportall	entity.name.function	exportall(): declare all current dynamic variables as exported variables.
extern	entity.name.function	extern(str): execute shell command str, and feeds the result to GP (as if loading from file).
externstr	entity.name.function	externstr(str): execute shell command str, and returns the result as a vector of GP strings, one component per output line.
factor	entity.name.function	factor(x,{D}): factorization of x over domain D. If x and D are both integers, return partial factorization, using primes < D.
factorback	entity.name.function	factorback(f,{e}): given a factorization f, gives the factored object back. If e is present, f has to be a vector of the same length, and we return the product of the f[i]^e[i].
factorcantor	entity.name.function	factorcantor(x,p): this function is obsolete, use factormod.
factorff	entity.name.function	factorff(x,{p},{a}): obsolete, use factormod.
factorial	entity.name.function	factorial(x): factorial of x, the result being given as a real number.
factorint	entity.name.function	factorint(x,{flag=0}): factor the integer x. flag is optional, whose binary digits mean 1: avoid MPQS, 2: avoid first-stage ECM (may fall back on it later), 4: avoid Pollard-Brent Rho and Shanks SQUFOF, 8: skip final ECM (huge composites will be declared prime).
factormod	entity.name.function	factormod(f,{D},{flag=0}): factors the polynomial f over the finite field defined by the domain D; flag is optional, and can be 0: default or 1: only the degrees of the irreducible factors are given.
factormodDDF	entity.name.function	factormodDDF(f,{D}): distinct-degree factorization of the squarefree polynomial f over the finite field defined by the domain D.
factormodSQF	entity.name.function	factormodSQF(f,{D}): squarefree factorization of the polynomial f over the finite field defined by the domain D.
factormodcyclo	entity.name.function	factormodcyclo(n, p, {single=0}, {v='x}): factor n-th cyclotomic polynomial mod p.
factornf	entity.name.function	factornf(x,t): this function is obsolete, use nffactor.
factorpadic	entity.name.function	factorpadic(pol,p,r): p-adic factorization of the polynomial pol to precision r.
ffcompomap	entity.name.function	ffcompomap(f, g): Let k, l, m be three finite fields and f a (partial) map from l to m and g a partial map from k to l, return the (partial) map f o g from k to m.
ffembed	entity.name.function	ffembed(a, b): given two elements a and b in finite fields, return a map embedding the definition field of a to the definition field of b.
ffextend	entity.name.function	ffextend(a, P, {v}): extend the field K of definition of a by a root of the polynomial P, assumed to be irreducible over K. Return [r, m] where r is a root of P in the extension field L and m is a map from K to L, see \kbd{ffmap}. If v is given, the variable name is used to display the generator of L, else the name of the variable of P is used.
fffrobenius	entity.name.function	fffrobenius(m,{n=1}): return the n-th power of the Frobenius map over the field of definition of m.
ffgen	entity.name.function	ffgen(k,{v = 'x}): return a generator of the finite field k (not necessarily a generator of its multiplicative group) as a t_FFELT. k can be given by its order q, the pair [p,f] with q=p^f, by an irreducible polynomial with t_INTMOD coefficients, or by a finite field element. If v is given, the variable name is used to display g, else the variable of the polynomial or finite field element, or x if only the order was given.
ffinit	entity.name.function	ffinit(p,n,{v='x}): monic irreducible polynomial of degree n over F_p[v].
ffinvmap	entity.name.function	ffinvmap(m): given a map m between finite fields, return a partial map that return the pre-images by the map m.
fflog	entity.name.function	fflog(x,g,{o}): return the discrete logarithm of the finite field element x in base g. If present, o must represent the multiplicative order of g. If no o is given, assume that g is a primitive root.
ffmap	entity.name.function	ffmap(m, x): given a (partial) map m between two finite fields, return the image of x by m. The function is applied recursively to the component of vectors, matrices and polynomials. If m is a partial map that is not defined at x, return []
ffmaprel	entity.name.function	ffmaprel(m, x): given a (partial) map m between two finite fields, express x as an algebraic element over the codomain of m in a way which is compatible with m. The function is applied recursively to the component of vectors, matrices and polynomials.
ffnbirred	entity.name.function	ffnbirred(q,n,{fl=0}): number of monic irreducible polynomials over F_q, of degree n (fl=0, default) or at most n (fl=1).
fforder	entity.name.function	fforder(x,{o}): multiplicative order of the finite field element x. Optional o represents a multiple of the order of the element.
ffprimroot	entity.name.function	ffprimroot(x, {&o}): return a primitive root of the multiplicative group of the definition field of the finite field element x (not necessarily the same as the field generated by x). If present, o is set to [ord, fa], where ord is the order of the group, and fa its factorization (useful in fflog and fforder).
fft	entity.name.function	fft(w,P): given w from rootsof1, return the discrete Fourier transform of P.
fftinv	entity.name.function	fftinv(w,P): given w from rootsof1, return the inverse Fourier transform of P.
fibonacci	entity.name.function	fibonacci(x): Fibonacci number of index x.
fileclose	entity.name.function	fileclose(n): close the file descriptor n.
fileextern	entity.name.function	fileextern(str): execute shell command str and returns a file descriptor attached to the command output as if it were read from a file.
fileflush	entity.name.function	fileflush({n}): flush the file descriptor n (all descriptors to output streams if n is omitted).
fileopen	entity.name.function	fileopen(path, mode): open the file pointed to by 'path' and return a file descriptor which can be used with other file functions. The mode is "r" (default, read), "w" (write, truncate), "a" (write, append).
fileread	entity.name.function	fileread(n): read a logical line from the file attached to the descriptor n, opened for reading with fileopen. Return 0 at end of file.
filereadstr	entity.name.function	filereadstr(n): read a raw line from the file attached to the descriptor n, opened for reading with fileopen. Discard the terminating newline. Return 0 at end of file.
filewrite	entity.name.function	filewrite(n, s): write the string s to file attached to descriptor n, ending with a newline. The file must have been opened with fileopen in "w" or "a" mode.
filewrite1	entity.name.function	filewrite1(n, s): write the string s to file number n without ending with newline.
floor	entity.name.function	floor(x): floor of x = largest integer <= x.
fold	entity.name.function	fold(f, A): return f(...f(f(A[1],A[2]),A[3]),...,A[#A]).
for	keyword.control	for(X=a,b,seq): the sequence is evaluated, X going from a up to b. If b is set to +oo, the loop will not stop.
forcomposite	keyword.control	forcomposite(n=a,{b},seq): the sequence is evaluated, n running over the composite numbers between a and b. Omitting b runs through composites >= a.
fordiv	keyword.control	fordiv(n,X,seq): the sequence is evaluated, X running over the divisors of n.
fordivfactored	keyword.control	fordivfactored(n,X,seq): the sequence is evaluated, X running over the [d, factor(d)], d a divisor of n.
foreach	keyword.control	foreach(V,X,seq): the sequence is evaluated, X running over the components of V.
forell	keyword.control	forell(E,a,b,seq,{flag=0}): execute seq for each elliptic curves E of conductor between a and b in the elldata database. If flag is nonzero, select only the first curve in each isogeny class.
forfactored	keyword.control	forfactored(N=a,b,seq): the sequence is evaluated, N is of the form [n, factor(n)], n going from a up to b.
forpart	keyword.control	forpart(X=k,seq,{a=k},{n=k}): evaluate seq where the Vecsmall X goes over the partitions of k. Optional parameter n (n=nmax or n=[nmin,nmax]) restricts the length of the partition. Optional parameter a (a=amax or a=[amin,amax]) restricts the range of the parts. Zeros are removed unless one sets amin=0 to get X of fixed length nmax (=k by default).
forperm	keyword.control	forperm(a,p,seq): the sequence is evaluated, p going through permutations of a.
forprime	keyword.control	forprime(p=a,{b},seq): the sequence is evaluated, p running over the primes between a and b. Omitting b runs through primes >= a.
forprimestep	keyword.control	forprimestep(p=a,b,q,seq): the sequence is evaluated, p running over the primes less than b in the arithmetic progression a + k*q, k >= 0. The parameter q can be a positive integer or an intmod (start at the first prime above a in the progression).
forqfvec	keyword.control	forqfvec(v,q,b,expr): q being a square and symmetric integral matrix representing an positive definite quadratic form, evaluate expr for all pairs of nonzero vectors (-v, v) such that q(v)<=b.
forsquarefree	keyword.control	forsquarefree(N=a,b,seq): the sequence is evaluated, N is of the form [n, factor(n)], n going through squarefree integers from a up to b.
forstep	keyword.control	forstep(X=a,b,s,seq): the sequence is evaluated, X going from a to b in steps of s (can be a positive real number, an intmod for an arithmetic progression, or finally a vector of steps). If b is set to +oo the loop will not stop.
forsubgroup	keyword.control	forsubgroup(H=G,{bound},seq): execute seq for each subgroup H of the abelian group G, whose index is bounded by bound if not omitted. H is given as a left divisor of G in HNF form.
forsubset	keyword.control	forsubset(nk, s, seq): if nk is an integer n, the sequence is evaluated, s going through all subsets of {1, 2, ..., n}; if nk is a pair [n,k] of integers s goes through k-subsets of {1, 2, ..., n}. The order is lexicographic among subsets of the same size and smaller subsets come first.
forvec	keyword.control	forvec(X=v,seq,{flag=0}): v being a vector of two-component vectors of length n, the sequence is evaluated with X[i] going from v[i][1] to v[i][2] for i=n,..,1 if flag is zero or omitted. If flag = 1 (resp. flag = 2), restrict to increasing (resp. strictly increasing) sequences.
frac	entity.name.function	frac(x): fractional part of x = x-floor(x).
fromdigits	entity.name.function	fromdigits(x,{b=10}): gives the integer formed by the elements of x seen as the digits of a number in base b.
galoischardet	entity.name.function	galoischardet(gal, chi, {o=1}): return the determinant character of the character chi.
galoischarpoly	entity.name.function	galoischarpoly(gal, chi, {o=1}): return the list of characteristic polynomials of the representation attached to the character chi.
galoischartable	entity.name.function	galoischartable(gal): return the character table of the underlying group of gal.
galoisconjclasses	entity.name.function	galoisconjclasses(gal): gal being output by galoisinit, return the list of conjugacy classes.
galoisexport	entity.name.function	galoisexport(gal,{flag}): gal being a Galois group as output by galoisinit, output a string representing the underlying permutation group in GAP notation (default) or Magma notation (flag = 1).
galoisfixedfield	entity.name.function	galoisfixedfield(gal,perm,{flag},{v=y}): gal being a Galois group as output by galoisinit and perm a subgroup, an element of gal.group or a vector of such elements, return [P,x] such that P is a polynomial defining the fixed field of gal[1] by the subgroup generated by perm, and x is a root of P in gal expressed as a polmod in gal.pol. If flag is 1 return only P. If flag is 2 return [P,x,F] where F is the factorization of gal.pol over the field defined by P, where the variable v stands for a root of P.
galoisgetgroup	entity.name.function	galoisgetgroup(a,{b}): query the galpol package for a group of order a with index b in the GAP4 Small Group library. If b is omitted, return the number of isomorphism classes of groups of order a.
galoisgetname	entity.name.function	galoisgetname(a,b): query the galpol package for a string describing the group of order a with index b in the GAP4 Small Group library.
galoisgetpol	entity.name.function	galoisgetpol(a,{b},{s}): query the galpol package for a polynomial with Galois group isomorphic to GAP4(a,b), totally real if s=1 (default) and totally complex if s=2. The output is a vector [pol, den] where pol is the polynomial and den is the common denominator of the conjugates expressed as a polynomial in a root of pol. If b and s are omitted, return the number of isomorphism classes of groups of order a.
galoisidentify	entity.name.function	galoisidentify(gal): gal being a Galois group as output by galoisinit, output the isomorphism class of the underlying abstract group as a two-components vector [o,i], where o is the group order, and i is the group index in the GAP4 small group library.
galoisinit	entity.name.function	galoisinit(pol,{den}): pol being a polynomial or a number field as output by nfinit defining a Galois extension of Q, compute the Galois group and all necessary information for computing fixed fields. den is optional and has the same meaning as in nfgaloisconj(,4)(see manual).
galoisisabelian	entity.name.function	galoisisabelian(gal,{flag=0}): gal being as output by galoisinit, return 0 if gal is not abelian, the HNF matrix of gal over gal.gen if flag=0, 1 if flag is 1, and the SNF matrix of gal if flag=2.
galoisisnormal	entity.name.function	galoisisnormal(gal,subgrp): gal being as output by galoisinit, and subgrp a subgroup of gal as output by galoissubgroups, return 1 if subgrp is a normal subgroup of gal, else return 0.
galoispermtopol	entity.name.function	galoispermtopol(gal,perm): gal being a Galois group as output by galoisinit and perm a element of gal.group, return the polynomial defining the corresponding Galois automorphism.
galoissplittinginit	entity.name.function	galoissplittinginit(P,{d}): Galois group over Q of the splitting field of P, that is the smallest field over which P is totally split. P is assumed to be integral, monic and irreducible; it can also be given by a nf structure. If d is given, it must be a multiple of the splitting field degree. The output is compatible with functions expecting a galoisinit structure.
galoissubcyclo	entity.name.function	galoissubcyclo(N,H,{fl=0},{v}): compute a polynomial (in variable v) defining the subfield of Q(zeta_n) fixed by the subgroup H of (Z/nZ)*. N can be an integer n, znstar(n) or bnrinit(bnfinit(y),[n,[1]]). H can be given by a generator, a set of generator given by a vector or a HNF matrix (see manual). If flag is 1, output only the conductor of the abelian extension. If flag is 2 output [pol,f] where pol is the polynomial and f the conductor. If flag is 3 output galoisinit(pol).
galoissubfields	entity.name.function	galoissubfields(G,{flag=0},{v}): output all the subfields of G; flag has the same meaning as for galoisfixedfield.
galoissubgroups	entity.name.function	galoissubgroups(G): output all the subgroups of G.
gamma	entity.name.function	gamma(s): gamma function at s, a complex or p-adic number, or a series.
gammah	entity.name.function	gammah(x): gamma of x+1/2 (x integer).
gammamellininv	entity.name.function	gammamellininv(G,t,{m=0}): returns G(t), where G is as output by gammamellininvinit (its m-th derivative if m is present).
gammamellininvasymp	entity.name.function	gammamellininvasymp(A,n,{m=0}): return the first n terms of the asymptotic expansion at infinity of the m-th derivative K^m(t) of the inverse Mellin transform of the function f(s)=Gamma_R(s+a_1)*...*Gamma_R(s+a_d), where Vga is the vector [a_1,...,a_d] and Gamma_R(s)=Pi^(-s/2)*gamma(s/2). The result is a vector [M[1]...M[n]] with M[1]=1, such that K^m(t) = (an elementary factor) * sum_n M[n+1] / x^n, where x = pi t^(2n/d).
gammamellininvinit	entity.name.function	gammamellininvinit(A,{m=0}): initialize data for the computation by gammamellininv() of the m-th derivative of the inverse Mellin transform of the function f(s) = Gamma_R(s+a1)*...*Gamma_R(s+ad), where A is the vector [a1,...,ad] and Gamma_R(s) = Pi^(-s/2)*gamma(s/2).
gcd	entity.name.function	gcd(x,{y}): greatest common divisor of x and y.
gcdext	entity.name.function	gcdext(x,y): returns [u,v,d] such that d=gcd(x,y) and u*x+v*y=d.
gcharalgebraic	entity.name.function	gcharalgebraic(gc,{type}): returns a matrix whose columns form a basis of the algebraic Grossencharacters in gc. If type is specified as a vector of integer exponents [p,q] for each complex place, return a vector containing an algebraic character of that infinity type (or the empty vector if such a character does not exist).
gcharconductor	entity.name.function	gcharconductor(gc,chi): returns the conductor of chi, as a modulus over gc.bnf.
gcharduallog	entity.name.function	gcharduallog(gc,chi): return logarithm vector of character chi in R^n. We have gchareval(g,chi,x,0) = gcharduallog(g,chi)*gcharlog(g,x)
gchareval	entity.name.function	gchareval(gc,chi,x,{flag=1}): compute the evaluation chi(x) in C* if flag=1 and in C/Z if flag=0.
gcharidentify	entity.name.function	gcharidentify(gc,Lv,Lchiv): returns a Grossencharacter chi belonging to gc that approximately satisfies the constraints that chi_v is Lchiv[i] at the place v=Lv[i].
gcharinit	entity.name.function	gcharinit(bnf,f): given a bnf as output by bnfinit and a modulus f, initializes data related to the group of Grossencharacters of conductor dividing this modulus.
gcharisalgebraic	entity.name.function	gcharisalgebraic(gc,chi,{&type}): returns 1 if chi is an algebraic (type A0) character. If type is present, set it to the infinity type [p,q] of chi.
gcharlocal	keyword.control	gcharlocal(gc,chi,v,{&BID}): if v is a place, return the local character chi_v. If v is a prime dividing the modulus and the optional argument 'BID' is present, set BID to the corresponding idealstar structure.
gcharlog	entity.name.function	gcharlog(gc,x): returns the internal representation (logarithm) of the ideal x suitable for computations in gc, as a column vector.
gcharnewprec	entity.name.function	gcharnewprec(gc): given a Grossencharacter group \kbd{gc}, recompute its invariants to ensure accurate results to current precision.
genus2red	entity.name.function	genus2red(PQ,{p}): let PQ be a polynomial P, resp. a vector [P,Q] of polynomials, with rational coefficients. Determines the reduction at p > 2 of the (proper, smooth) hyperelliptic curve C/Q of genus 2 defined by y^2 = P, resp. y^2 + Q*y = P. More precisely, determines the special fiber X_p of the minimal regular model X of C over Z.
getabstime	entity.name.function	getabstime(): milliseconds of CPU time since startup.
getcache	entity.name.function	getcache(): returns information about various auto-growing caches. For each resource, we report its name, its size, the number of cache misses (since the last extension) and the largest cache miss.
getenv	entity.name.function	getenv(s): value of the environment variable s, 0 if it is not defined.
getheap	entity.name.function	getheap(): 2-component vector giving the current number of objects in the heap and the space they occupy (in long words).
getlocalbitprec	entity.name.function	getlocalbitprec(): returns the current dynamic bit precision.
getlocalprec	entity.name.function	getlocalprec(): returns the current dynamic precision, in decimal digits.
getrand	entity.name.function	getrand(): current value of random number seed.
getstack	entity.name.function	getstack(): current value of stack pointer avma.
gettime	entity.name.function	gettime(): milliseconds of CPU time used since the last call to gettime.
getwalltime	entity.name.function	getwalltime(): time (in milliseconds) since the UNIX Epoch.
global	keyword.control	global(list of variables): obsolete. Scheduled for deletion.
halfgcd	entity.name.function	halfgcd(x,y): return a vector [M, [a,b]~], where M is an invertible 2x2 matrix such that M*[x,y]~ = [a,b]~, where b is small. More precisely, if x,y are integers, we have b < sqrt(max(|x|,|y|)) <= a. If x,y are polynomials, we have deg b < ceil((max(|x|,|y|))/2) <= deg a.
hammingweight	entity.name.function	hammingweight(x): returns the Hamming weight of x.
harmonic	entity.name.function	harmonic(n,{r = 1}): generalized harmonic number of index n in power r.
hgmalpha	entity.name.function	hgmalpha(H): returns the alpha and beta parameters of the hypergeometric motive template H.
hgmbydegree	entity.name.function	hgmbydegree(n): outputs [L(0),...,L(n-1)] where L(w) is the list of cyclotomic parameters of all possible hypergeometric motive templates of degree n and weight w.
hgmcoef	entity.name.function	hgmcoef(H,t,n): (H,t) being a hypergeometric motive, returns the n-th coefficient of its L-function.
hgmcoefs	entity.name.function	hgmcoefs(H,t,n): (H,t) being a hypergeometric motive, returns the first n coefficients of its L-function, where Euler factors at wild primes are set to 1.
hgmcyclo	entity.name.function	hgmcyclo(H): returns the cyclotomic parameters (D,E) of the hypergeometric motive template H.
hgmeulerfactor	entity.name.function	hgmeulerfactor(H, t, p, {&e}): (H,t) being a hypergeometric motive, returns the Euler factor P_p at the prime p; if present, set e to the valuation of the conductor at p.
hgmgamma	entity.name.function	hgmgamma(H): returns the gamma vector of the hypergeometric motive template H.
hgminit	entity.name.function	hgminit(a, {b}): Create the template for a hypergeometric motive with parameters a and possibly b. The format of the parameters may be alpha: Galois invariant lists of rational numbers a=alpha and b=beta; or cyclo: lists A and B of positive integers corresponding to alpha and beta; or gamma: list of cn such that the hypergeometric quotient is prod_n(x^n-1)^cn.
hgmissymmetrical	entity.name.function	hgmissymmetrical(H): is the hypergeometric motive template H symmetrical at t=1?
hgmparams	entity.name.function	hgmparams(H): H being a hypergeometric motive template, returns [d, w, [P, T], M], where d is the degree, w the weight, P the Hodge polynomial and T the Tate twist number (so that the Hodge function itself is P/x^T); finally M is the so-called M-value.
hgmtwist	entity.name.function	hgmtwist(H): twist by 1/2 of alpha and beta of the hypergeometric motive template H.
hilbert	entity.name.function	hilbert(x,y,{p}): Hilbert symbol at p of x,y.
hyperellchangecurve	entity.name.function	hyperellchangecurve(C, m): C being a nonsingular hyperelliptic model of a curve, apply the change of coordinate given by m. C can be given either by a squarefree polynomial P such that C:y^2=P(x) or by a vector [P,Q] such that C:y^2+Q(x)*y=P(x) and Q^2+4P is squarefree.
hyperellcharpoly	entity.name.function	hyperellcharpoly(X): X being a nonsingular hyperelliptic curve defined over a finite field, return the characteristic polynomial of the Frobenius automorphism. X can be given either by a squarefree polynomial P such that X:y^2=P(x) or by a vector [P,Q] such that X:y^2+Q(x)*y=P(x) and Q^2+4P is squarefree.
hyperelldisc	entity.name.function	hyperelldisc(X): X being a nonsingular hyperelliptic model of a curve, return its discriminant. X can be given either by a squarefree polynomial P such that X:y^2=P(x) or by a vector [P,Q] such that X:y^2+Q(x)*y=P(x) and Q^2+4P is squarefree.
hyperellisoncurve	entity.name.function	hyperellisoncurve(X, p): X being a nonsingular hyperelliptic model of a curve, test whether the point p is on the curve. X can be given either by a squarefree polynomial P such that X:y^2=P(x) or by a vector [P,Q] such that X:y^2+Q(x)*y=P(x) and Q^2+4P is squarefree.
hyperellminimaldisc	entity.name.function	hyperellminimaldisc(C,{pr}): C being a nonsingular integral hyperelliptic model of a curve, return the minimal discrminant of an integral model of C. If pr is given, it must be a list of primes and the discriminant is then only garanteed minimal at the elements of pr. C can be given either by a squarefree polynomial P such that C:y^2=P(x) or by a vector [P,Q] such that C:y^2+Q(x)*y=P(x) and Q^2+4P is squarefree.
hyperellminimalmodel	entity.name.function	hyperellminimalmodel(C,{&m},{pr}): C being a nonsingular integral hyperelliptic model of a curve, return an integral model of C with minimal discriminant. If pr is given, it must be a list of primes and the model is then only garanteed minimal at the elements of pr. C can be given either by a squarefree polynomial P such that C:y^2=P(x) or by a vector [P,Q] such that C:y^2+Q(x)*y=P(x) and Q^2+4P is squarefree.
hyperellpadicfrobenius	entity.name.function	hyperellpadicfrobenius(Q,q,n): Q being a rational polynomial of degree d and X being the curve defined by y^2=Q(x), return the matrix of the Frobenius at the prime q >= d in the standard basis of H^1_dR(X) to absolute q-adic precision q^n; q may also be of the form [T,p] where T is an integral polynomial which is irreducible mod p.
hyperellratpoints	entity.name.function	hyperellratpoints(X,h,{flag=0}): X being a nonsingular hyperelliptic curve given by an rational model, return a vector containing the affine rational points on the curve of naive height less than h. If fl=1, stop as soon as a point is found. X can be given either by a squarefree polynomial P such that X:y^2=P(x) or by a vector [P,Q] such that X:y^2+Q(x)y=P(x) and Q^2+4P is squarefree.
hyperellred	entity.name.function	hyperellred(C,{&m}): C being a nonsingular integral hyperelliptic model of a curve, return an integral model of C with the same discriminant but small coefficients. C can be given either by a squarefree polynomial P such that C:y^2=P(x) or by a vector [P,Q] such that C:y^2+Q(x)*y=P(x) and Q^2+4P is squarefree.
hypergeom	entity.name.function	hypergeom({N},{D},z): general hypergeometric function, where N and D are the vector of parameters in the numerator and denominator respectively, evaluated at the complex argument z.
hyperu	entity.name.function	hyperu(a,b,z): U-confluent hypergeometric function.
idealadd	entity.name.function	idealadd(nf,x,y): sum of two ideals x and y in the number field defined by nf.
idealaddtoone	entity.name.function	idealaddtoone(nf,x,{y}): if y is omitted, when the sum of the ideals in the number field K defined by nf and given in the vector x is equal to Z_K, gives a vector of elements of the corresponding ideals who sum to 1. Otherwise, x and y are ideals, and if they sum up to 1, find one element in each of them such that the sum is 1.
idealappr	entity.name.function	idealappr(nf,x,{flag}): x being a fractional ideal, gives an element b such that v_p(b)=v_p(x) for all prime ideals p dividing x, and v_p(b)>=0 for all other p; x may also be a prime ideal factorization with possibly zero exponents. flag is deprecated (ignored), kept for backward compatibility.
idealchinese	entity.name.function	idealchinese(nf,x,{y}): x being a prime ideal factorization and y a vector of elements, gives an element b such that v_p(b-y_p)>=v_p(x) for all prime ideals p dividing x, and v_p(b)>=0 for all other p. If y is omitted, return a data structure which can be used in place of x in later calls.
idealcoprime	entity.name.function	idealcoprime(nf,x,y): gives an element b in nf such that b. x is an integral ideal coprime to the integral ideal y.
idealdiv	entity.name.function	idealdiv(nf,x,y,{flag=0}): quotient x/y of two ideals x and y in HNF in the number field nf. If (optional) flag is nonzero, the quotient is supposed to be an integral ideal (slightly faster).
idealdown	entity.name.function	idealdown(nf,x): finds the intersection of the ideal x with Q.
idealfactor	entity.name.function	idealfactor(nf,x,{lim}): factorization of the ideal x into prime ideals in the number field nf. If lim is set return partial factorization, using primes < lim.
idealfactorback	entity.name.function	idealfactorback(nf,f,{e},{flag = 0}): given a factorization f, gives the ideal product back. If e is present, f has to be a vector of the same length, and we return the product of the f[i]^e[i]. If flag is nonzero, perform idealred along the way.
idealfrobenius	entity.name.function	idealfrobenius(nf,gal,pr): returns the Frobenius element (pr|nf/Q) attached to the unramified prime ideal pr in prid format, in the Galois group gal of the number field nf.
idealhnf	entity.name.function	idealhnf(nf,u,{v}): hermite normal form of the ideal u in the number field nf if v is omitted. If called as idealhnf(nf,u,v), the ideal is given as uZ_K + vZ_K in the number field K defined by nf.
idealintersect	entity.name.function	idealintersect(nf,A,B): intersection of two ideals A and B in the number field defined by nf.
idealinv	entity.name.function	idealinv(nf,x): inverse of the ideal x in the number field nf.
idealismaximal	entity.name.function	idealismaximal(nf,x): if x is a maximal ideal, return it in prid form, else return 0.
idealispower	entity.name.function	idealispower(nf,A,n,{&B}): return 1 if A = B^n is an n-th power else return 0.
ideallist	entity.name.function	ideallist(nf,bound,{flag=4}): vector of vectors L of all idealstar of all ideals of norm<=bound. If (optional) flag is present, its binary digits are toggles meaning 1: give generators; 2: add units; 4: give only the ideals and not the bid; 8: omit ideals which cannot be conductors.
ideallistarch	entity.name.function	ideallistarch(nf,list,arch): list is a vector of vectors of bid's as output by ideallist. Return a vector of vectors with the same number of components as the original list. The leaves give information about moduli whose finite part is as in original list, in the same order, and Archimedean part is now arch. The information contained is of the same kind as was present in the input.
ideallog	entity.name.function	ideallog({nf},x,bid): if bid is a big ideal, as given by idealstar(nf,D,...), gives the vector of exponents on the generators bid.gen (even if these generators have not been explicitly computed).
idealmin	entity.name.function	idealmin(nf,ix,{vdir}): pseudo-minimum of the ideal ix in the direction vdir in the number field nf.
idealmul	entity.name.function	idealmul(nf,x,y,{flag=0}): product of the two ideals x and y in the number field nf. If (optional) flag is nonzero, reduce the result.
idealnorm	entity.name.function	idealnorm(nf,x): norm of the ideal x in the number field nf.
idealnumden	entity.name.function	idealnumden(nf,x): returns [A,B], where A,B are coprime integer ideals such that x = A/B.
idealpow	entity.name.function	idealpow(nf,x,k,{flag=0}): k-th power of the ideal x in HNF in the number field nf. If (optional) flag is nonzero, reduce the result.
idealprimedec	entity.name.function	idealprimedec(nf,p,{f=0}): prime ideal decomposition of the prime number p in the number field nf as a vector of prime ideals. If f is present and nonzero, restrict the result to primes of residue degree <= f.
idealprincipalunits	entity.name.function	idealprincipalunits(nf,pr,k): returns the structure [no, cyc, gen] of the multiplicative group (1 + pr) / (1 + pr^k).
idealramgroups	entity.name.function	idealramgroups(nf,gal,pr): let pr be a prime ideal in prid format, and gal the Galois group of the number field nf, return a vector g such that g[1] is the decomposition group of pr, g[2] is the inertia group, g[i] is the (i-2)th ramification group of pr, all trivial subgroups being omitted.
idealred	entity.name.function	idealred(nf,I,{v=0}): LLL reduction of the ideal I in the number field nf along direction v, in HNF.
idealredmodpower	entity.name.function	idealredmodpower(nf,x,n,{B=primelimit}): return b such that x * b^n = v is small.
idealstar	entity.name.function	idealstar({nf},N,{flag=1},{cycmod}): gives the structure of (Z_K/N)^*, where N is a modulus (an ideal in any form or a vector [f0, foo], where f0 is an ideal and foo is a {0,1}-vector with r1 components. If the positive integer cycmod is present, only compute the group modulo cycmod-th powers. flag is optional, and can be 0: structure as an abelian group [h,d,g] where h is the order, d the orders of the cyclic factors and g the generators; if flag=1 (default), gives a bid structure used in ideallog to compute discrete logarithms; underlying generators are well-defined but not explicitly computed, which saves time; if flag=2, same as with flag=1 except that the generators are also given. If nf is omitted, N must be an integer and we return the structure of (Z/NZ)^*.
idealtwoelt	entity.name.function	idealtwoelt(nf,x,{a}): two-element representation of an ideal x in the number field nf. If (optional) a is nonzero, first element will be equal to a.
idealval	entity.name.function	idealval(nf,x,pr): valuation at pr given in idealprimedec format of the ideal x in the number field nf.
if	entity.name.function	if(a,{seq1},{seq2}): if a is nonzero, seq1 is evaluated, otherwise seq2. seq1 and seq2 are optional, and if seq2 is omitted, the preceding comma can be omitted also.
iferr	keyword.control	iferr(seq1,E,seq2,{pred}): evaluates the expression sequence seq1. If an error occurs, set the formal parameter E set to the error data. If pred is not present or evaluates to true, catch the error and evaluate seq2. Both pred and seq2 can reference E.
imag	entity.name.function	imag(x): imaginary part of x.
incgam	entity.name.function	incgam(s,x,{g}): incomplete gamma function. g is optional and is the precomputed value of gamma(s).
incgamc	entity.name.function	incgamc(s,x): complementary incomplete gamma function.
inline	keyword.control	inline(x,...,z): declares x,...,z as inline variables. DEPRECATED, use export.
input	keyword.control	input(): read an expression from the input file or standard input.
install	entity.name.function	install(name,code,{gpname},{lib}): load from dynamic library 'lib' the function 'name'. Assign to it the name 'gpname' in this GP session, with prototype 'code'. If 'lib' is omitted, all symbols known to gp (includes the whole 'libpari.so' and possibly others) are available. If 'gpname' is omitted, use 'name'.
intcirc	keyword.control	intcirc(X=a,R,expr,{tab}): numerical integration of expr on the circle |z-a|=R, divided by 2*I*Pi. tab is as in intnum.
intformal	entity.name.function	intformal(x,{v}): formal integration of x with respect to v, or to the main variable of x if v is omitted.
intfuncinit	keyword.control	intfuncinit(t=a,b,f,{m=0}): initialize tables for integrations from a to b using a weight f(t). For integral transforms such as Fourier or Mellin transforms.
intnum	keyword.control	intnum(X=a,b,expr,{tab}): numerical integration of expr from a to b with respect to X. Plus/minus infinity is coded as +oo/-oo. Finally tab is either omitted (let the program choose the integration step), a nonnegative integer m (divide integration step by 2^m), or data precomputed with intnuminit.
intnumgauss	keyword.control	intnumgauss(X=a,b,expr,{tab}): numerical integration of expr from a to b, a compact interval, with respect to X using Gauss-Legendre quadrature. tab is either omitted (and will be recomputed) or precomputed with intnumgaussinit.
intnumgaussinit	entity.name.function	intnumgaussinit({n}): initialize tables for n-point Gauss-Legendre integration on a compact interval.
intnuminit	entity.name.function	intnuminit(a,b,{m=0}): initialize tables for integrations from a to b. See help for intnum for coding of a and b. Possible types: compact interval, semi-compact (one extremity at + or - infinity) or R, and very slowly, slowly or exponentially decreasing, or sine or cosine oscillating at infinities.
intnumosc	keyword.control	intnumosc(x=a,expr,H,{flag=0},{tab}): numerical integration from a to oo of oscillating quasi-periodic function expr of half-period H. tab is either omitted (and will be recomputed) or precomputed with intnumgaussinit; flag is either 0 (Sidi extrapolation, safe mode), 1 (Sidi extrapolation, unsafe mode), 2 (sumalt), 3 (sumnumlagrange), 4 (sumpos).
intnumromb	keyword.control	intnumromb(X=a,b,expr,{flag=0}): numerical integration of expr (smooth in ]a,b[) from a to b with respect to X. flag is optional and mean 0: default. expr can be evaluated exactly on [a,b]; 1: general function; 2: a or b can be plus or minus infinity (chosen suitably), but of same sign; 3: expr has only limits at a or b.
isfundamental	entity.name.function	isfundamental(D): true(1) if D is a fundamental discriminant (including 1), false(0) if not.
ispolygonal	entity.name.function	ispolygonal(x,s,{&N}): true(1) if x is an s-gonal number, false(0) if not (s > 2). If N is given set it to n if x is the n-th s-gonal number.
ispower	entity.name.function	ispower(x,{k},{&n}): if k > 0 is given, return true (1) if x is a k-th power, false (0) if not. If k is omitted, return the maximal k >= 2 such that x = n^k is a perfect power, or 0 if no such k exist. If n is present, and the function returns a nonzero result, set n to the k-th root of x.
ispowerful	entity.name.function	ispowerful(x): true(1) if x is a powerful integer (valuation at all primes dividing x is greater than 1), false(0) if not.
isprime	entity.name.function	isprime(x,{flag=0}): true(1) if x is a (proven) prime number, false(0) if not. If flag is 0 or omitted, use a combination of algorithms. If flag is 1, the primality is certified by the Pocklington-Lehmer Test. If flag is 2, the primality is certified using the APRCL test. If flag is 3, use ECPP.
isprimepower	entity.name.function	isprimepower(x,{&n}): if x = p^k is a prime power (p prime, k > 0), return k, else return 0. If n is present, and the function returns a nonzero result, set n to p, the k-th root of x.
ispseudoprime	entity.name.function	ispseudoprime(x,{flag}): true(1) if x is a strong pseudoprime, false(0) if not. If flag is 0 or omitted, use BPSW test, otherwise use strong Rabin-Miller test for flag randomly chosen bases.
ispseudoprimepower	entity.name.function	ispseudoprimepower(x,{&n}): if x = p^k is a pseudo-prime power (p pseudo-prime, k > 0), return k, else return 0. If n is present, and the function returns a nonzero result, set n to p, the k-th root of x.
issquare	entity.name.function	issquare(x,{&n}): true(1) if x is a square, false(0) if not. If n is given puts the exact square root there if it was computed.
issquarefree	entity.name.function	issquarefree(x): true(1) if x is squarefree, false(0) if not.
istotient	entity.name.function	istotient(x,{&N}): true(1) if x = eulerphi(n) for some integer n, false(0) if not. If N is given, set N = n as well.
kill	entity.name.function	kill(sym): restores the symbol sym to its ``undefined'' status and kill attached help messages.
kronecker	entity.name.function	kronecker(x,y): kronecker symbol (x/y).
lambertw	entity.name.function	lambertw(y,{branch=0}): solution of the implicit equation x*exp(x)=y. In the p-adic case, give a solution of x*exp(x)=y if y has valuation > 1 (or p odd and positive valuation), of log(x)+x=log(y) otherwise.
laurentseries	entity.name.function	laurentseries(f, {M = seriesprecision}, {x='x}): expand f around 0 as a Laurent series in x to order M.
lcm	entity.name.function	lcm(x,{y}): least common multiple of x and y, i.e. x*y / gcd(x,y) up to units.
length	entity.name.function	length(x): number of non code words in x, number of characters for a string.
lerchphi	entity.name.function	lerchphi(z, s, a): Lerch transcendent equal to sum for n >= 0 of z^n / (n+a)^s for reasonable values of the arguments.
lerchzeta	entity.name.function	lerchzeta(s, a, lam): Lerch zeta function equal to sum for n >= 0 of e^(2 pi i lam n) / (n+a)^s for reasonable values of the arguments.
lex	entity.name.function	lex(x,y): compare x and y lexicographically (1 if x>y, 0 if x=y, -1 if x<y).
lfun	entity.name.function	lfun(L,s,{D=0}): compute the L-function value L(s), or if D is set, the derivative of order D at s. L is either an Lmath, an Ldata or an Linit.
lfunabelianrelinit	entity.name.function	lfunabelianrelinit(bnfL,bnfK,polrel,sdom,{der=0}): returns the Linit structure attached to the Dedekind zeta function of the number field L, given a subfield K such that L/K is abelian, where polrel defines L over K. The priority of the variable of bnfK must be lower than that of polrel; bnfL is the absolute polynomial corresponding to polrel, and sdom and der are as in lfuninit.
lfunan	entity.name.function	lfunan(L,n): compute the first n terms of the Dirichlet series attached to the L-function given by L (Lmath, Ldata or Linit).
lfunartin	entity.name.function	lfunartin(nf,gal,rho,n): returns the Ldata structure attached to the Artin L-function provided by the representation rho of the Galois group of the extension K/Q, defined over the cyclotomic field Q(zeta_n), where nf is the nfinit structure attached to K, gal is the galoisinit structure attached to K/Q, and rho is given either by the values of its character on the conjugacy classes or by the matrices that are the images of the generators. Cyclotomic numbers in rho are represented by polynomials, whose variable is understood as the complex number exp(2*I*Pi/n).
lfuncheckfeq	entity.name.function	lfuncheckfeq(L,{t}): given an L-function (Lmath, Ldata or Linit), check whether the functional equation is satisfied. If the function has poles, the polar part must be specified. The program returns a bit accuracy which should be a large negative value close to the current bit accuracy. If t is given, it checks the functional equation for the theta function at t and 1/t.
lfunconductor	entity.name.function	lfunconductor(L, {setN = 10000},{flag=0}): give the conductor of the given L-function, expecting to find it in the interval [1,setN]. If flag=0 (default), give either the conductor found as an integer, or a vector of conductors found, possibly empty. If flag=1, same but give the computed floating point approximations to the conductors found, without rounding to integers. If flag=2, give all the conductors found, even those far from integers. Alternatively, setN can contain a list of possible conductors and we select the best one according to lfuncheckfeq; in this case, flag is ignored and we return [N, lfuncheckfeq for that N].
lfuncost	entity.name.function	lfuncost(L,{sdom},{der=0}): estimate the cost of running lfuninit(L,sdom,der) at current bit precision. Returns [t,b], to indicate that t coefficients a_n will be computed at bit accuracy b. Subsequent evaluation of lfun at s evaluates a polynomial of degree t at exp(h s). If L is already an Linit, then sdom and der are ignored.
lfuncreate	entity.name.function	lfuncreate(obj): given either an object such as a polynomial, elliptic curve, Dirichlet or Hecke character, eta quotient, etc., or an explicit 6 or 7 component vector [dir,real,Vga,k,N,eps,r], create the Ldata structure necessary for lfun computation.
lfundiv	entity.name.function	lfundiv(L1,L2): creates the Ldata structure (without initialization) corresponding to the quotient of the Dirichlet series given by L1 and L2.
lfundual	entity.name.function	lfundual(L): creates the Ldata structure (without initialization) corresponding to the dual L-function of L.
lfunetaquo	entity.name.function	lfunetaquo(M): returns the Ldata structure attached to the modular form z->prod(i=1,#M[,1],eta(M[i,1]*z)^M[i,2]).
lfuneuler	entity.name.function	lfuneuler(L,p): return the Euler factor at p of the L-function given by L (Lmath, Ldata or Linit) if it is exists and can be determined.
lfungenus2	entity.name.function	lfungenus2(F): returns the Ldata structure attached to the L-function attached to the genus-2 curve defined by y^2=F(x) or y^2+Q(x)*y=P(x) if F=[P,Q]. Currently, only odd conductors are supported.
lfunhardy	entity.name.function	lfunhardy(L,t): variant of the Hardy L-function attached to L, used for plotting on the critical line.
lfunhgm	entity.name.function	lfunhgm(H,t,{hint}): (H,t) being a hypergeometric motive, returns the corresponding lfuncreate data for use with the L function package.
lfuninit	entity.name.function	lfuninit(L,sdom,{der=0}): precompute data for evaluating the L-function given by 'L' (and its derivatives of order der, if set) in rectangular domain sdom = [center,w,h] centered on the real axis, |Re(s)-center| <= w, |Im(s)| <= h, where all three components of sdom are real and w,h are nonnegative. The subdomain [k/2, 0, h] on the critical line can be encoded as [h] for brevity.
lfunlambda	entity.name.function	lfunlambda(L,s,{D=0}): compute the completed L function Lambda(s), or if D is set, the derivative of order D at s. L is either an Lmath, an Ldata or an Linit.
lfunmf	entity.name.function	lfunmf(mf,{F}): If F is a modular form in mf, output the L-functions corresponding to its complex embeddings. If F is omitted, output the L-functions corresponding to all eigenforms in the new space.
lfunmfspec	entity.name.function	lfunmfspec(L): L corresponding to a modular eigenform, returns [ve,vo,om,op] in even weight, where ve (resp., vo) is the vector of even (resp., odd) periods, and om and op the corresponding real numbers omega^- and omega^+. Returns [v,om] in odd weight.
lfunmul	entity.name.function	lfunmul(L1,L2): creates the Ldata structure (without initialization) corresponding to the product of the Dirichlet series given by L1 and L2.
lfunorderzero	entity.name.function	lfunorderzero(L, {m = -1}): computes the order of the possible zero of the L-function at the center k/2 of the critical strip. If m is given and has a nonnegative value, assumes the order is at most m.
lfunparams	entity.name.function	lfunparams(ldata): return the parameters [N, k, vga] of the L-function defined by ldata (see lfuncreate). The parameters Vga (gamma shifts) are returned to the current precision.
lfunqf	entity.name.function	lfunqf(Q): returns the Ldata structure attached to the theta function of the lattice attached to the definite positive quadratic form Q.
lfunrootres	entity.name.function	lfunrootres(data): given the Ldata attached to an L-function (or the output of lfunthetainit), compute the root number and the residues. In the present implementation, if the polar part is not already known completely, at most a single pole is allowed. The output is a 3-component vector [[[a_1, r_1],...,[a_n, r_n],[[b_1, R_1],...[b_m,R_m]]~, w], where r_i is the polar part of L(s) at a_i, R_i is is the polar part of Lambda(s) at b_i, or [0,0,r] if there is no pole, and w is the root number.
lfunshift	entity.name.function	lfunshift(L,d,{flag}): creates the Ldata structure (without initialization) corresponding to the function Ld such that Ld(s) = L(s-d). If fl=1, return the product L*Ld instead.
lfunsympow	entity.name.function	lfunsympow(E, m): returns the Ldata structure attached to the L-function attached to m-th symmetric power of the elliptic curve E defined over the rationals.
lfuntheta	entity.name.function	lfuntheta(data,t,{m=0}): compute the value of the m-th derivative at t of the theta function attached to the L-function given by data. data can be either the standard L-function data, or the output of lfunthetainit.
lfunthetacost	entity.name.function	lfunthetacost(L,{tdom},{m=0}): estimates the cost of running lfunthetainit(L,tdom,m) at current bit precision. Returns the number of coefficients an that would be computed. Subsequent evaluation of lfuntheta computes that many values of gammamellininv. If L is already an Linit, then tdom and m are ignored.
lfunthetainit	entity.name.function	lfunthetainit(L,{tdom},{m=0}): precompute data for evaluating the m-th derivative of theta functions with argument in domain tdom (by default t is real >= 1).
lfuntwist	entity.name.function	lfuntwist(L,chi): creates the Ldata structure (without initialization) corresponding to the twist of L by the primitive character attached to the Dirichlet L-function chi. This requires that the conductor of the character is coprime to the conductor of the L-function L.
lfunzeros	entity.name.function	lfunzeros(L,lim,{divz=8}): lim being either an upper limit or a real interval, computes an ordered list of zeros of L(s) on the critical line up to the given upper limit or in the given interval. Use a naive algorithm which may miss some zeros. To use a finer search mesh, set divz to some integral value larger than the default (= 8).
lift	entity.name.function	lift(x,{v}): if v is omitted, lifts elements of Z/nZ to Z, of Qp to Q, and of K[x]/(P) to K[x]. Otherwise lift only polmods with main variable v.
liftall	entity.name.function	liftall(x): lifts every element of Z/nZ to Z, of Qp to Q, and of K[x]/(P) to K[x].
liftint	entity.name.function	liftint(x): lifts every element of Z/nZ to Z and of Qp to Q.
liftpol	entity.name.function	liftpol(x): lifts every polmod component of x to polynomials.
limitnum	entity.name.function	limitnum(expr,{alpha=1}): numerical limit of sequence expr using Lagrange-Zagier extrapolation; assume u(n) ~ sum a_i n^(-alpha*i).
lindep	entity.name.function	lindep(v,{flag=0}): integral linear dependencies between components of v. flag is optional, and can be 0: default, guess a suitable accuracy, or positive: accuracy to use for the computation, in decimal digits.
listcreate	entity.name.function	listcreate({n}): this function is obsolete, use List().
listinsert	entity.name.function	listinsert(~L,x,n): insert x at index n in list L, shifting the remaining elements to the right.
listkill	entity.name.function	listkill(~L): obsolete, retained for backward compatibility.
listpop	entity.name.function	listpop(~list,{n}): removes n-th element from list. If n is omitted or greater than the current list length, removes last element.
listput	entity.name.function	listput(~list,x,{n}): sets n-th element of list equal to x. If n is omitted or greater than the current list length, appends x.
listsort	entity.name.function	listsort(~L,{flag=0}): sort the list L in place. If flag is nonzero, suppress all but one occurrence of each element in list.
lngamma	entity.name.function	lngamma(x): logarithm of the gamma function of x.
local	keyword.control	local(x,...,z): declare x,...,z as (dynamically scoped) local variables.
localbitprec	entity.name.function	localbitprec(p): set the real precision to p bits in the dynamic scope.
localprec	entity.name.function	localprec(p): set the real precision to p in the dynamic scope and return p.
log	entity.name.function	log(x): natural logarithm of x.
log1p	entity.name.function	log1p(x): log(1+x)
logint	entity.name.function	logint(x,b,{&z}): return the largest non-negative integer e so that b^e <= x, where b > 1 is an integer and x >= 1 is a real number. If the parameter z is present, set it to b^e.
mapdelete	entity.name.function	mapdelete(~M,x): removes x from the domain of the map M.
mapget	entity.name.function	mapget(M,x): returns the image of x by the map M.
mapisdefined	entity.name.function	mapisdefined(M,x,{&z}): true (1) if x has an image by the map M, false (0) otherwise. If z is present, set it to the image of x, if it exists.
mapput	entity.name.function	mapput(~M,x,y): associates x to y in the map M.
matadjoint	entity.name.function	matadjoint(M,{flag=0}): adjoint matrix of M using Leverrier-Faddeev's algorithm. If flag is 1, compute the characteristic polynomial independently first.
matalgtobasis	entity.name.function	matalgtobasis(nf,x): nfalgtobasis applied to every element of the vector or matrix x.
matbasistoalg	entity.name.function	matbasistoalg(nf,x): nfbasistoalg applied to every element of the matrix or vector x.
matcompanion	entity.name.function	matcompanion(x): companion matrix to polynomial x.
matconcat	entity.name.function	matconcat(v): concatenate the entries of v and return the resulting matrix.
matdet	entity.name.function	matdet(x,{flag=0}): determinant of the matrix x using an appropriate algorithm depending on the coefficients. If (optional) flag is set to 1, use classical Gaussian elimination (usually worse than the default).
matdetint	entity.name.function	matdetint(B): some multiple of the determinant of the lattice generated by the columns of B (0 if not of maximal rank). Useful with mathnfmod.
matdetmod	entity.name.function	matdetmod(x,d): determinant of the matrix x modulo d.
matdiagonal	entity.name.function	matdiagonal(x): creates the diagonal matrix whose diagonal entries are the entries of the vector x.
mateigen	entity.name.function	mateigen(x,{flag=0}): complex eigenvectors of the matrix x given as columns of a matrix H. If flag=1, return [L,H], where L contains the eigenvalues and H the corresponding eigenvectors.
matfrobenius	entity.name.function	matfrobenius(M,{flag},{v='x}): return the Frobenius form of the square matrix M. If flag is 1, return only the elementary divisors as a vector of polynomials in the variable v. If flag is 2, return a two-components vector [F,B] where F is the Frobenius form and B is the basis change so that M=B^-1*F*B.
mathess	entity.name.function	mathess(x): Hessenberg form of x.
mathilbert	entity.name.function	mathilbert(n): Hilbert matrix of order n.
mathnf	entity.name.function	mathnf(M,{flag=0}): (upper triangular) Hermite normal form of M, basis for the lattice formed by the columns of M. Basic values of flag are 0 (default): only return the Hermite normal form H, 1: return [H,U] such that H is the HNF of M, and U is an invertible matrix such that MU=H. These two use a naive algorithm; larger values of flag correspond to more involved algorithms and are restricted to integer matrices; flag = 4: returns [H,U] using LLL reduction along the way; flag = 5: return [H,U,P] where P is a permutation of row indices such that P applied to M U is H.
mathnfmod	entity.name.function	mathnfmod(x,d): (upper triangular) Hermite normal form of x, basis for the lattice formed by the columns of x, where d is a multiple of the nonzero determinant of this lattice.
mathnfmodid	entity.name.function	mathnfmodid(x,d): (upper triangular) Hermite normal form of x concatenated with matdiagonal(d).
mathouseholder	entity.name.function	mathouseholder(Q,v): applies a sequence Q of Householder transforms to the vector or matrix v.
matid	entity.name.function	matid(n): identity matrix of order n.
matimage	entity.name.function	matimage(x,{flag=0}): basis of the image of the matrix x. flag is optional and can be set to 0 or 1, corresponding to two different algorithms.
matimagecompl	entity.name.function	matimagecompl(x): vector of column indices not corresponding to the indices given by the function matimage.
matimagemod	entity.name.function	matimagemod(x,d,&U): basis of the image of the matrix x modulo d.
matindexrank	entity.name.function	matindexrank(M): gives two extraction vectors (rows and columns) for the matrix M such that the extracted matrix is square of maximal rank.
matintersect	entity.name.function	matintersect(x,y): intersection of the vector spaces whose bases are the columns of x and y.
matinverseimage	entity.name.function	matinverseimage(x,y): an element of the inverse image of the vector y by the matrix x if one exists, the empty vector otherwise.
matinvmod	entity.name.function	matinvmod(x,d): left inverse of the matrix x modulo d.
matisdiagonal	entity.name.function	matisdiagonal(x): true(1) if x is a diagonal matrix, false(0) otherwise.
matker	entity.name.function	matker(x,{flag=0}): basis of the kernel of the matrix x. flag is optional, and may be set to 0: default; nonzero: x is known to have integral entries.
matkerint	entity.name.function	matkerint(x,{flag=0}): LLL-reduced Z-basis of the kernel of the matrix x with integral entries; flag is deprecated, kept for backward compatibility.
matkermod	entity.name.function	matkermod(x,d,&im): basis of the kernel of the matrix x modulo d.
matmuldiagonal	entity.name.function	matmuldiagonal(x,d): product of matrix x by diagonal matrix whose diagonal coefficients are those of the vector d, equivalent but faster than x*matdiagonal(d).
matmultodiagonal	entity.name.function	matmultodiagonal(x,y): product of matrices x and y, knowing that the result will be a diagonal matrix. Much faster than general multiplication in that case.
matpascal	entity.name.function	matpascal(n,{q}): Pascal triangle of order n if q is omitted. q-Pascal triangle otherwise.
matpermanent	entity.name.function	matpermanent(x): permanent of the matrix x.
matqr	entity.name.function	matqr(M,{flag=0}): returns [Q,R], the QR-decomposition of the square invertible matrix M. If flag=1, Q is given as a sequence of Householder transforms (faster and stabler).
matrank	entity.name.function	matrank(x): rank of the matrix x.
matreduce	entity.name.function	matreduce(m): reduce the factorization matrix m to canonical form (sorted first row with unique elements) matrix.
matrix	entity.name.function	matrix(m,{n=m},{X},{Y},{expr=0}): m x n matrix of expression expr, where the row variable X goes from 1 to m and the column variable Y goes from 1 to n. By default, fill with 0s.
matrixqz	entity.name.function	matrixqz(A,{p=0}): if p>=0, transforms the rational or integral mxn (m>=n) matrix A into an integral matrix with gcd of maximal determinants coprime to p. If p=-1, finds a basis of the intersection with Z^n of the lattice spanned by the columns of A. If p=-2, finds a basis of the intersection with Z^n of the Q-vector space spanned by the columns of A.
matsize	entity.name.function	matsize(x): number of rows and columns of the vector/matrix x as a 2-vector.
matsnf	entity.name.function	matsnf(X,{flag=0}): Smith normal form (i.e. elementary divisors) of the matrix X, expressed as a vector d; X must have integer or polynomial entries. Binary digits of flag mean 1: returns [u,v,d] where d=u*X*v, otherwise only the diagonal d is returned, 4: removes all information corresponding to entries equal to 1 in d.
matsolve	entity.name.function	matsolve(M,B): solution of MX=B (M matrix, B column vector or matrix).
matsolvemod	entity.name.function	matsolvemod(M,D,B,{flag=0}): one solution of system of congruences MX=B mod D (M matrix, B and D column vectors). If (optional) flag is nonzero return all solutions.
matsupplement	entity.name.function	matsupplement(x): supplement the columns of the matrix x to an invertible matrix.
mattranspose	entity.name.function	mattranspose(x): x~ = transpose of x.
max	entity.name.function	max(x,y): maximum of x and y.
mfDelta	entity.name.function	mfDelta(): mf corresponding to the Ramanujan Delta function.
mfEH	entity.name.function	mfEH(k): k>0 being in 1/2+Z, mf corresponding to the Cohen-Eisenstein series H_k of weight k on G_0(4).
mfEk	entity.name.function	mfEk(k): mf corresponding to the standard Eisenstein series E_k for nonnegative even integer k.
mfTheta	entity.name.function	mfTheta({psi=1}): the unary theta function corresponding to the primitive Dirichlet character psi, hence of weight 1/2 if psi is even, of weight 3/2 if psi is odd.
mfatkin	entity.name.function	mfatkin(mfatk,f): Given an mfatk output by mfatk = mfatkininit(mf,Q) and a modular form f belonging to the space mf, returns the modular form g = C*f|W_Q where C = mfatk[3] is a normalizing constant so that g has the same field of coefficients as f; mfatk[1] = mf2 (or 0 if mf2=mf) which is the space to which g belongs.
mfatkineigenvalues	entity.name.function	mfatkineigenvalues(mf,Q): given a modular form space mf and a primitive divisor Q of the level of mf, outputs the corresponding Atkin-Lehner eigenvalues on the new space, grouped by orbit.
mfatkininit	entity.name.function	mfatkininit(mf,Q): initializes data necessary for working with Atkin--Lehner operators W_Q, for now only the function mfatkin. The result is a 4-component vector [mfB, MC, C, mf] where mfB is either 0 or the possibly different modular form space to which F|W_Q will belong (this does not depend on F in mf); MC is the matrix of W_Q on the basis of mf multiplied by a normalizing constant C.
mfbasis	entity.name.function	mfbasis(NK,{space=4}): If NK=[N,k,CHI] as in mfinit, gives a basis of the corresponding subspace of M_k(G_0(N),CHI). NK can also be the output of mfinit, in which case space is ignored. To obtain the eigenforms use mfeigenbasis.
mfbd	entity.name.function	mfbd(F,d): F being a generalized modular form, return B(d)(F), where B(d) is the expanding operator tau -> d tau.
mfbracket	entity.name.function	mfbracket(F,G,{m=0}): compute the m-th Rankin-Cohen bracket of the generalized modular forms F and G.
mfcoef	entity.name.function	mfcoef(F,n): Compute the n-th Fourier coefficient a(n) of the generalized modular form F.
mfcoefs	entity.name.function	mfcoefs(F,n,{d = 1}): Compute the vector of coefficients [a[0],a[d],...,a[nd]] of the modular form F.
mfconductor	entity.name.function	mfconductor(mf,F): mf being output by mfinit and F a modular form, gives the smallest level at which F is defined.
mfcosets	entity.name.function	mfcosets(N): list of right cosets of G_0(N)\G, i.e., matrices g_j in G such that G = U G_0(N) g_j. The g_j are chosen in the form [a,b; c,d] with c | N.
mfcuspisregular	entity.name.function	mfcuspisregular(NK, cusp): In the space defined by NK = [N,k,CHI] or NK = mf, determine if cusp in canonical format (oo or denominator dividing N) is regular or not.
mfcusps	entity.name.function	mfcusps(N): list of cusps of G_0(N) in the form a/b with b dividing N.
mfcuspval	entity.name.function	mfcuspval(mf,F,cusp): valuation of modular form F in the space mf at cusp, which can be either oo or any rational number. The result is either a rational number or oo if F is zero. Let chi be the Nebentypus of the space mf; if Q(F) != Q(chi), return the vector of valuations attached to the [Q(F):Q(chi)] complex embeddings of F.
mfcuspwidth	entity.name.function	mfcuspwidth(N, cusp): width of cusp in Gamma_0(N).
mfderiv	entity.name.function	mfderiv(F,{m=1}): m-th formal derivative of the power series corresponding to the generalized modular form F, with respect to the differential operator q.d/dq (default m=1).
mfderivE2	entity.name.function	mfderivE2(F,{m=1}): compute the Serre derivative (q.d/dq)F - kE_2F/12 of the generalized modular form F of weight k; and if m > 1, the m-th iterate.
mfdescribe	entity.name.function	mfdescribe(F,{&G}): gives a human-readable description of F, which is either a modular form space or a modular form. If the address of G is given, puts into G the vector of parameters of the outmost operator defining F.
mfdim	entity.name.function	mfdim(NK,{space=4}): If NK=[N,k,CHI] as in mfinit, gives the dimension of the corresponding subspace of M_k(G_0(N),chi). The subspace is described by a small integer 'space': 0 for the newspace, 1 for the cuspidal space, 2 for the oldspace, 3 for the space of Eisenstein series and 4 (default) for the full space M_k. NK can also be the output of mfinit, in which case space must be omitted.
mfdiv	entity.name.function	mfdiv(F,G): compute F/G for two modular forms F and G assuming that the quotient will not have poles at infinity. If this is the case, use mfshift before doing the division.
mfeigenbasis	entity.name.function	mfeigenbasis(mf): vector of the eigenforms for the space mf.
mfeigensearch	entity.name.function	mfeigensearch(NK,{AP}): search for normalized rational eigen cuspforms with quadratic characters given a few initial coefficients. The meaning of the parameters is as follows: NK is of the form [N,k]: search given level N, weight k and quadratic character; note that the character is uniquely determined by (N,k). The level N can be replaced by a vector of allowed levels. AP is the search criterion, which can be omitted: a list of pairs [...,[p,a_p],...], where a_p is either a t_INT (exact match) or a t_INTMOD (match modulo the given integer). The result is a vector of newforms matching the search criteria, sorted by increasing level.
mfeisenstein	entity.name.function	mfeisenstein(k,{CHI1},{CHI2}): create the Eisenstein E_k(CHI1,CHI2), where an omitted character is considered as trivial.
mfembed	entity.name.function	mfembed(f,{v}): if v is omitted, f must be a modular form or a modular form space with parameters [N,k,chi] and we return a vector of complex embeddings of Q(f) or Q(chi), respectively. If v is given, it must be a scalar in Q(f), or a vector/matrix of such, we apply the embeddings coefficientwise and return a vector of results. Finally f can be replaced by a single embedding produced by mfembed(f) and we apply that particular embedding to v. Note that, in our context, Q(chi) has a single canonical embeding given by s: Mod(t, polcyclo(n,t)) -> exp(2*I*Pi/n) and Q(f) has [Q(f):Q(chi)] induced embeddings attached to the complex roots of s(P) where P = mfparams(f)[4], as ordered by polroots. In the latter case, we only support an f with Q(f) = Q(chi) or an eigenform produced by mfeigenbasis.
mfeval	entity.name.function	mfeval(mf,F,vtau): computes the numerical value of the modular form F at the point vtau or the vector vtau of points in the completed upper-half plane.
mffields	entity.name.function	mffields(mf): If mf is output by mfinit, gives the vector of polynomials defining each Galois orbit of the new space.
mffromell	entity.name.function	mffromell(E): E being an elliptic curve defined over Q given by an integral model in ellinit format, computes a 3-component vector [mf,F,v], where F is the newform corresponding to E by modularity, mf is the newspace to which F belongs, and v gives the coefficients of F on mfbasis(mf).
mffrometaquo	entity.name.function	mffrometaquo(eta,{flag=0}): modular form corresponding to the eta quotient matrix eta. If the valuation v at infinity is fractional, return 0. If the eta quotient is not holomorphic but simply meromorphic, return 0 if flag=0; return the eta quotient (divided by q to the power -v if v < 0, i.e., with valuation 0) if flag is set.
mffromlfun	entity.name.function	mffromlfun(L): L being an L-function representing a self-dual modular form, return [NK,space,v] where mf=mfinit(NK,space) contains the form and mftobasis(mf, v) containing it and v is mftobasis(mf,f).
mffromqf	entity.name.function	mffromqf(Q,{P}): Q being an even positive definite quadratic form and P a homogeneous spherical polynomial for Q, computes a 3-component vector [mf,F,coeffs], where F is the theta function corresponding to (Q, P), mf is the corresponding space of modular forms from mfinit, and coeffs are the coefficients of F on mfbasis(mf).
mfgaloisprojrep	entity.name.function	mfgaloisprojrep(mf,F): mf being an mf output by mfinit in weight 1, and F an eigenform, returns a polynomial defining the field fixed by the kernel of the projective representation associated to F.
mfgaloistype	entity.name.function	mfgaloistype(NK,{F}): NK being either [N,1,CHI] or an mf output by mfinit in weight 1 , gives the vector of types of Galois representations attached to each cuspidal eigenform, unless the eigenform F is specified, in which case only for F. Types A_4, S_4, A_5 are represented by minus their cardinality -12, -24, or -60, and type D_n is represented by its cardinality, the integer 2*n.
mfhecke	entity.name.function	mfhecke(mf,F,n): F being a modular form in space mf, returns T(n)F, where T(n) is the n-th Hecke operator. Warning: if F is of level M<N, T(n)F is in general not the same in M_k(G_0(M),CHI) and in M_k(G_0(N),CHI). We take T(n) at the same level as the one used in mf.
mfheckemat	entity.name.function	mfheckemat(mf,vecn): if vecn is an integer, matrix of the Hecke operator T(n) on the basis formed by mfbasis(mf), if it is a vector, vector of such matrices.
mfinit	entity.name.function	mfinit(NK,{space=4}): Create the space of modular forms corresponding to the data contained in NK and space. NK is a vector which can be either [N,k] (N level, k weight) corresponding to a subspace of M_k(G_0(N)), or [N,k,CHI] (CHI a character) corresponding to a subspace of M_k(G_0(N),chi). The subspace is described by a small integer 'space': 0 for the newspace, 1 for the cuspidal space, 2 for the oldspace, 3 for the space of Eisenstein series and 4 (default) for the full space M_k
mfisCM	entity.name.function	mfisCM(F): Tests whether the eigenform F is a CM form. The answer is 0 if it is not, and if it is, either the unique negative discriminant of the CM field, or the pair of two negative discriminants of CM fields, this latter case occurring only in weight 1 when the projective image is D2=C2xC2, i.e., coded 4 by mfgaloistype.
mfisequal	entity.name.function	mfisequal(F,G,{lim=0}): Checks whether the modular forms F and G are equal. If lim is nonzero, only check equality of the first lim+1 Fourier coefficients.
mfisetaquo	entity.name.function	mfisetaquo(f,{flag=0}): if the generalized modular form f is a holomorphic eta quotient, return the eta quotient matrix, else return 0. If flag is set, also accept meromorphic eta quotients.
mfkohnenbasis	entity.name.function	mfkohnenbasis(mf): mf being a cuspidal space of half-integral weight k >= 3/2, gives a basis B of the Kohnen + space of mf as a matrix whose columns are the coefficients of B on the basis of mf.
mfkohnenbijection	entity.name.function	mfkohnenbijection(mf): mf being a cuspidal space of half-integral weight returns [mf2,M,K,shi], where M is a matrix giving a Hecke-module isomorphism from S_{2k-1}(N,CHI^2) given by mf2 to the Kohnen + space S_k+(4N,CHI), K is a basis of the Kohnen + space, and shi gives the linear combination of Shimura lifts giving M^(-1).
mfkohneneigenbasis	entity.name.function	mfkohneneigenbasis(mf,bij): mf being a cuspidal space of half-integral weight k >= 3/2 and bij being the output of mfkohnenbijection(mf), outputs a 3-component vector [mf0,BNEW,BEIGEN], where BNEW and BEIGEN are two matrices whose columns are the coefficients of a basis of the Kohnen new space and of the eigenforms on the basis of mf respectively, and mf0 is the corresponding new space of integral weight 2k - 1.
mflinear	entity.name.function	mflinear(vF,v): vF being a vector of modular forms and v a vector of coefficients of same length, compute the linear combination of the entries of vF with coefficients v.
mfmanin	entity.name.function	mfmanin(FS): Given the modular symbol FS associated to an eigenform F by mfsymbol(mf,F), computes the even and odd special polynomials as well as the even and odd periods om+ and om- as a vector [[P+,P-],[om+,om-,r]], where r = imag(om+*conj(om-))/<F,F>. If F has several embeddings into C, give the vector of results corresponding to each embedding.
mfmul	entity.name.function	mfmul(F,G): Multiply the two forms F and G.
mfnumcusps	entity.name.function	mfnumcusps(N): number of cusps of Gamma_0(N)
mfparams	entity.name.function	mfparams(F): If F is a modular form space, returns [N,k,CHI,space,Phi]: level, weight, character, and space code; where Phi is the cyclotomic polynomial defining the field of values of CHI. If F is a modular form, returns [N,k,CHI,P,Phi], where P is the (polynomial giving the) field of definition of F: in that case the level N may be a multiple of the level of F and the polynomial P may define a larger field than Q(F).
mfperiodpol	entity.name.function	mfperiodpol(mf,f,{flag=0}): period polynomial of the cuspidal part of the form f, in other words integral from 0 to ioo of (X-tau)^(k-2)f(tau). If flag=0, ordinary period polynomial, if flag=1 or -1, even or odd part of that polynomial. f can also be the modular symbol output by mfsymbol(mf,f).
mfperiodpolbasis	entity.name.function	mfperiodpolbasis(k,{flag=0}): basis of period polynomials for weight k. If flag=1 or -1, basis of odd or even period polynomials.
mfpetersson	entity.name.function	mfpetersson(fs,{gs}): Petersson scalar product of the modular forms f and g belonging to the same modular form space mf, given by the corresponding "modular symbols" fs and gs output by mfsymbol (also in weight 1 and half-integral weight). If gs is omitted it is understood to be equal to fs. The scalar product is normalized by the factor 1/[G:G_0(N)].
mfpow	entity.name.function	mfpow(F,n): compute F^n
mfsearch	entity.name.function	mfsearch(NK,V,{space}): NK being of the form [N,k] with k possibly half-integral, search for a modular form with rational coefficients, of weight k and level N, whose initial coefficients a(0),... are equal to V; space specifies the modular form spaces in which to search. The output is a list of matching forms with that given level and weight. Note that the character is of the form (D/.), where D is a (positive or negative) fundamental discriminant dividing N. N can be replaced by a vector of allowed levels, in which case the list of forms is sorted by increasing level, then increasing |D|. If a form is found at level N, any multiple of N with the same D is not considered Note that this is very different from mfeigensearch, which only searches for rational eigenforms.
mfshift	entity.name.function	mfshift(F,s): Divide the form F by q^s omitting the remainder if there is one; s can be negative.
mfshimura	entity.name.function	mfshimura(mf, F, {D = 1}): F being a modular form of half-integral weight k >= 3/2 and t a positive squarefree integer, computes the Shimura lift G of weight 2k-1 corresponding to D. This function returns [mf2,G,v], where mf2 is a modular form space containing G, and v the vector of coefficients of G on mf.
mfslashexpansion	entity.name.function	mfslashexpansion(mf,f,g,n,flrat,{&params}): g being in M_2^+(Q), computes the Fourier expansion of f|_k g to n terms. f must belong to the space mf. If params is given, it is set to the parameters [alpha,w,A]. If flrat is 1, the program tries to rationalize the expression; if flag is 0, it does not.
mfspace	entity.name.function	mfspace(mf,{f}): identify the modular space mf, resp. the modular form f in mf. Returns 0 (newspace), 1 (cuspidal space), 2 (old space), 3 (Eisenstein space) or 4 (full space). Return -1 when the form does not belong to the space.
mfsplit	entity.name.function	mfsplit(mf,{dimlim=0},{flag=0}): mf containing the new space split the new space into Galois orbits of eigenforms of the newspace and return [vF,vK], where vF gives the (Galois orbit of) eigenforms in terms of mfbasis(mf) and vK is a list of polynomials defining each Galois orbit. If dimlim is set only the Galois orbits of dimension <= dimlim are computed (i.e. the rational eigenforms if dimlim = 1 and the character is real). Flag speeds up computations when the dimension is large: if flag = d > 0, when the dimension of the eigenspace is > d, only the Galois polynomial is computed.
mfsturm	entity.name.function	mfsturm(NK): Sturm bound for modular forms on G_0(N) and weight k, i.e., an upper bound for the order of the zero at infinity of a nonzero form. NK is either [N,k] or an mfinit (exact bound in the latter case).
mfsymbol	entity.name.function	mfsymbol(mf,f): Initialize data for working with all period polynomials of the modular form f: this is essential for efficiency for functions such as mfsymboleval, mfmanin, and mfpetersson. By abuse of language, initialize data for working with mfpetersson in weight 1 or half-integral weight (where no symbol exist).
mfsymboleval	entity.name.function	mfsymboleval(fs,path,{ga=id}): evaluation of the modular symbol fs output by mfsymbol on the given path, where path is either a vector [s1,s2] or an integral matrix [a,b;c,d] representing the path [a/c,b/d]. In both cases, s1 or s2 (or a/c or b/d) can also be elements of the upper half-plane. The result is the polynomial equal to the integral between s1 and s2 of (X-tau)^{k-2}F(tau). If ga in GL_2+(Q) is given, replace F by F|_k ga. If the integral diverges, the result will be a rational function.
mftaylor	entity.name.function	mftaylor(F,n,{flreal=0}): F being a modular form in M_k(SL_2(Z)), computes the first n+1 canonical Taylor expansion of F around tau=I. If flreal=0, computes only an algebraic equivalence class. If flreal is set, compute p_n such that for tau close enough to I we have f(tau)=(2I/(tau+I))^ksum_{n>=0}p_n((tau-I)/(tau+I))^n.
mftobasis	entity.name.function	mftobasis(mf,F,{flag=0}): coefficients of the form F on the basis given by the mfbasis(mf). A q-expansion or vector of coefficients can also be given instead of F, but in this case an error message may occur if the expansion is too short. An error message is also given if F does not belong to the modular form space. If flag is set, instead of error messages return an output as an affine space of solutions if a q-expansion or vector of coefficients is given, or the empty column otherwise.
mftocoset	entity.name.function	mftocoset(N,M,Lcosets): M being a matrix in SL_2(Z) and Lcosets being mfcosets(N), find the right coset of G_0(N) to which M belongs. The output is a pair [ga,i] such that M = ga * Lcosets[i], with ga in G_0(N).
mftonew	entity.name.function	mftonew(mf,F): mf being a full or cuspidal space with parameters [N,k,chi] and F a cusp form in that space, returns a vector of 3-component vectors [M,d,G], where f(chi) divides M divides N, d divides N/M, and G is a form in S_k^new(G_0(M),chi) such that F is equal to the sum of the B(d)(G) over all these 3-component vectors.
mftraceform	entity.name.function	mftraceform(NK,{space=0}): If NK=[N,k,CHI,.] as in mfinit with k integral, gives the trace form in the corresponding subspace of S_k(G_0(N),chi). The supported values for space are 0: the newspace (default), 1: the full cuspidal space.
mftwist	entity.name.function	mftwist(F,D): returns the twist of the form F by the integer D, i.e., the form G such that mfcoef(G,n)=(D/n)mfcoef(F,n), where (D/n) is the Kronecker symbol.
min	entity.name.function	min(x,y): minimum of x and y.
minpoly	entity.name.function	minpoly(A,{v='x}): minimal polynomial of the matrix or polmod A.
modreverse	entity.name.function	modreverse(z): reverse polmod of the polmod z, if it exists.
moebius	entity.name.function	moebius(x): Moebius function of x.
msatkinlehner	entity.name.function	msatkinlehner(M,Q,{H}): M being a full modular symbol space of level N, as given by msinit, let Q | N, (Q,N/Q) = 1, and let H be a subspace stable under the Atkin-Lehner involution w_Q. Return the matrix of w_Q acting on H (M if omitted).
mscosets	entity.name.function	mscosets(gen, inH): gen being a system of generators for a group G and H being a subgroup of finite index of G, return a list of right cosets of H \ G and the right action of G on H \ G. The subgroup H is given by a criterion inH (closure) deciding whether an element of G belongs to H.
mscuspidal	entity.name.function	mscuspidal(M, {flag=0}): M being a full modular symbol space, as given by msinit, return its cuspidal part S. If flag = 1, return [S,E] its decomposition into Eisenstein and cuspidal parts.
msdim	entity.name.function	msdim(M): M being a modular symbol space or subspace, return its dimension as a Q-vector space.
mseisenstein	entity.name.function	mseisenstein(M): M being a full modular symbol space, as given by msinit, return its Eisenstein subspace.
mseval	entity.name.function	mseval(M,s,{p}): M being a full modular symbol space, as given by msinit, s being a modular symbol from M and p being a path between two elements in P^1(Q), return s(p).
msfarey	entity.name.function	msfarey(F,inH,{&CM}): F being a Farey symbol attached to a group G contained in SL2(Z) and H a subgroup of G, return a Farey symbol attached to H; H is given by a criterion inH (closure) deciding whether an element of G belongs to H.
msfromcusp	entity.name.function	msfromcusp(M, c): returns the modular symbol attached to the cusp c, where M is a modular symbol space of level N.
msfromell	entity.name.function	msfromell(E, {sign=0}): return the [M, x], where M is msinit(N,2) and x is the modular symbol in M attached to the elliptic curve E/Q.
msfromhecke	entity.name.function	msfromhecke(M, v, {H}): given a msinit M and a vector v of pairs [p, P] (where p is prime and P is a polynomial with integer coefficients), return a basis of all modular symbols such that P(Tp) * s = 0. If H is present, it must be a Hecke-stable subspace and we restrict to s in H.
msgetlevel	entity.name.function	msgetlevel(M): M being a full modular symbol space, as given by msinit, return its level N.
msgetsign	entity.name.function	msgetsign(M): M being a full modular symbol space, as given by msinit, return its sign.
msgetweight	entity.name.function	msgetweight(M): M being a full modular symbol space, as given by msinit, return its weight k.
mshecke	entity.name.function	mshecke(M,p,{H}): M being a full modular symbol space, as given by msinit, p being a prime number, and H being a Hecke-stable subspace (M if omitted), return the matrix of T_p acting on H (U_p if p divides the level).
msinit	entity.name.function	msinit(G, V, {sign=0}): given G a finite index subgroup of SL(2,Z) and a finite dimensional representation V of GL(2,Q), creates a space of modular symbols, the G-module Hom_G(Div^0(P^1 Q), V). This is canonically isomorphic to H^1_c(X(G), V), and allows to compute modular forms for G. If sign is present and nonzero, it must be +1 or -1 and we consider the subspace defined by Ker (Sigma - sign), where Sigma is induced by [-1,0;0,1]. Currently the only supported groups are the Gamma_0(N), coded by the integer N. The only supported representation is V_k = Q[X,Y]_{k-2}, coded by the integer k >= 2.
msissymbol	entity.name.function	msissymbol(M,s): M being a full modular symbol space, as given by msinit, check whether s is a modular symbol attached to M.
mslattice	entity.name.function	mslattice(M, {H}): M being a full modular symbol space, as given by msinit, H a Q-subspace or a matrix of modular symbols. Return the canonical integral structure of H.
msnew	entity.name.function	msnew(M): M being a full modular symbol space, as given by msinit, return its new cuspidal subspace.
msomseval	entity.name.function	msomseval(Mp, PHI, path): return the vectors of moments of the p-adic distribution attached to the path 'path' via the overconvergent modular symbol 'PHI'.
mspadicL	entity.name.function	mspadicL(mu, {s = 0}, {r = 0}): given mu from mspadicmoments (p-adic distributions attached to an overconvergent symbol PHI) returns the value on a character of Z_p^* represented by s of the derivative of order r of the p-adic L-function attached to PHI.
mspadicinit	entity.name.function	mspadicinit(M, p, n, {flag}): M being a full modular symbol space, as given by msinit and a prime p, initialize technical data needed to compute with overconvergent modular symbols (modulo p^n). If flag is unset, allow all symbols; if flag = 0, restrict to ordinary symbols; else initialize for symbols phi such that Tp(phi) = a_p * phi, with v_p(a_p) >= flag.
mspadicmoments	entity.name.function	mspadicmoments(Mp, PHI, {D = 1}): given Mp from mspadicinit, an overconvergent eigensymbol PHI, and optionally a fundamental discriminant D coprime to p, return the moments of the p-1 distributions PHI^D([0]-[oo]) | (a + pZp), 0 < a < p. To be used by mspadicL and mspadicseries.
mspadicseries	entity.name.function	mspadicseries(mu, {i=0}): given mu from mspadicmoments, returns the attached p-adic series with maximal p-adic precision, depending on the precision of M (i-th Teichmueller component, if present).
mspathgens	entity.name.function	mspathgens(M): M being a full modular symbol space, as given by msinit, return a set of Z[G]-generators for Div^0(P^1 Q). The output is [g,R], where g is a minimal system of generators and R the vector of Z[G]-relations between the given generators.
mspathlog	entity.name.function	mspathlog(M,p): M being a full modular symbol space, as given by msinit and p being a path between two elements in P^1(Q), return (p_i) in Z[G] such that p = \sum p_i g_i, and the g_i are fixed Z[G]-generators for Div^0(P^1 Q), see mspathgens.
mspetersson	entity.name.function	mspetersson(M, {F}, {G=F}): M being a full modular symbol space, as given by msinit, calculate the intersection product {F,G} of modular symbols F and G on M.
mspolygon	entity.name.function	mspolygon(M, {flag = 0}): M describes a subgroup G of finite index in the modular group PSL2(Z), as given by msinit or a positive integer N (encoding the group G = Gamma0(N)), or by msfarey (arbitrary subgroups). Return an hyperbolic polygon (Farey symbol) attached to G. Binary digits of flag mean: 1=normalized polygon, 2=also add graphical representations.
msqexpansion	entity.name.function	msqexpansion(M,projH,{B = seriesprecision}): M being a full modular symbol space, as given by msinit, and projH being a projector on a Hecke-simple subspace, return the Fourier coefficients [a_n, n <= B] of the corresponding normalized newform. If B omitted, use seriesprecision.
mssplit	entity.name.function	mssplit(M,{H},{dimlim}): M being a full modular symbol space, as given by msinit, and H being a subspace (the new subspace if omitted), split H into Hecke-simple subspaces. If dimlim is present and positive, restrict to dim <= dimlim.
msstar	entity.name.function	msstar(M,{H}): M being a full modular symbol space, as given by msinit, return the matrix of the * involution, induced by complex conjugation, acting on the (stable) subspace H (M if omitted).
mstooms	entity.name.function	mstooms(Mp, phi): given Mp from mspadicinit, lift the (classical) eigen symbol phi to a distribution-valued overconvergent symbol in the sense of Pollack and Stevens. The resulting overconvergent eigensymbol can then be used in mspadicmoments, then mspadicL or mspadicseries.
my	keyword.control	my(x,...,z): declare x,...,z as lexically-scoped local variables.
newtonpoly	entity.name.function	newtonpoly(x,p): Newton polygon of polynomial x with respect to the prime p.
next	keyword.control	next({n=1}): interrupt execution of current instruction sequence, and start another iteration from the n-th innermost enclosing loops.
nextprime	entity.name.function	nextprime(x): smallest pseudoprime >= x.
nfalgtobasis	entity.name.function	nfalgtobasis(nf,x): transforms the algebraic number x into a column vector on the integral basis nf.zk.
nfbasis	entity.name.function	nfbasis(T, {&dK}): integral basis of the field Q[a], where a is a root of the polynomial T, using the round 4 algorithm. An argument [T,listP] is possible, where listP is a list of primes or a prime bound, to get an order which is maximal at certain primes only. If present, dK is set to the discriminant of the returned order.
nfbasistoalg	entity.name.function	nfbasistoalg(nf,x): transforms the column vector x on the integral basis into an algebraic number.
nfcertify	entity.name.function	nfcertify(nf): returns a vector of composite integers used to certify nf.zk and nf.disc unconditionally (both are correct when the output is the empty vector).
nfcompositum	entity.name.function	nfcompositum(nf,P,Q,{flag=0}): vector of all possible compositums of the number fields defined by the polynomials P and Q; flag is optional, whose binary digits mean 1: output for each compositum, not only the compositum polynomial pol, but a vector [R,a,b,k] where a (resp. b) is a root of P (resp. Q) expressed as a polynomial modulo R, and a small integer k such that al2+k*al1 is the chosen root of R; 2: assume that the number fields defined by P and Q are linearly disjoint.
nfdetint	entity.name.function	nfdetint(nf,x): multiple of the ideal determinant of the pseudo generating set x.
nfdisc	entity.name.function	nfdisc(T): discriminant of the number field defined by the polynomial T. An argument [T,listP] is possible, where listP is a list of primes or a prime bound.
nfdiscfactors	entity.name.function	nfdiscfactors(T): [D, faD], where D = nfdisc(T), and faD is the factorization of |D|.
nfeltadd	entity.name.function	nfeltadd(nf,x,y): element x+y in nf.
nfeltdiv	entity.name.function	nfeltdiv(nf,x,y): element x/y in nf.
nfeltdiveuc	entity.name.function	nfeltdiveuc(nf,x,y): gives algebraic integer q such that x-qy is small.
nfeltdivmodpr	entity.name.function	nfeltdivmodpr(nf,x,y,pr): this function is obsolete, use nfmodpr.
nfeltdivrem	entity.name.function	nfeltdivrem(nf,x,y): gives [q,r] such that r=x-qy is small.
nfeltembed	entity.name.function	nfeltembed(nf,x,{pl}): complex embeddings of x at places given by vector pl.
nfeltispower	entity.name.function	nfeltispower(nf,x,n,{&y}): return 1 if x is an n-th power (and set y to an n-th root if present), else return 0.
nfeltissquare	entity.name.function	nfeltissquare(nf,x,{&y}): return 1 if x is a square (and set y to a square root if present), else return 0.
nfeltmod	entity.name.function	nfeltmod(nf,x,y): gives r such that r=x-qy is small with q algebraic integer.
nfeltmul	entity.name.function	nfeltmul(nf,x,y): element x.y in nf.
nfeltmulmodpr	entity.name.function	nfeltmulmodpr(nf,x,y,pr): this function is obsolete, use nfmodpr.
nfeltnorm	entity.name.function	nfeltnorm(nf,x): norm of x.
nfeltpow	entity.name.function	nfeltpow(nf,x,k): element x^k in nf.
nfeltpowmodpr	entity.name.function	nfeltpowmodpr(nf,x,k,pr): this function is obsolete, use nfmodpr.
nfeltreduce	entity.name.function	nfeltreduce(nf,a,id): gives r such that a-r is in the ideal id and r is small.
nfeltreducemodpr	entity.name.function	nfeltreducemodpr(nf,x,pr): this function is obsolete, use nfmodpr.
nfeltsign	entity.name.function	nfeltsign(nf,x,{pl}): signs of real embeddings of x at places given by vector pl.
nfelttrace	entity.name.function	nfelttrace(nf,x): trace of x.
nfeltval	entity.name.function	nfeltval(nf,x,pr,{&y}): valuation of element x at the prime pr as output by idealprimedec.
nffactor	entity.name.function	nffactor(nf,T): factor polynomial T in number field nf.
nffactorback	entity.name.function	nffactorback(nf,f,{e}): given a factorization f, returns the factored object back as an nf element.
nffactormod	entity.name.function	nffactormod(nf,Q,pr): this routine is obsolete, use nfmodpr and factormod. Factor polynomial Q modulo prime ideal pr in number field nf.
nfgaloisapply	entity.name.function	nfgaloisapply(nf,aut,x): apply the Galois automorphism aut to the object x (element or ideal) in the number field nf.
nfgaloisconj	entity.name.function	nfgaloisconj(nf,{flag=0},{d}): list of conjugates of a root of the polynomial x=nf.pol in the same number field. flag is optional (set to 0 by default), meaning 0: use combination of flag 4 and 1, always complete; 1: use nfroots; 4: use Allombert's algorithm, complete if the field is Galois of degree <= 35 (see manual for details). nf can be simply a polynomial.
nfgrunwaldwang	entity.name.function	nfgrunwaldwang(nf,Lpr,Ld,pl,{v='x}): a polynomial in the variable v defining a cyclic extension of nf (given in nf or bnf form) with local behavior prescribed by Lpr, Ld and pl: the extension has local degree a multiple of Ld[i] at the prime Lpr[i], and the extension is complex at the i-th real place of nf if pl[i]=-1 (no condition if pl[i]=0). The extension has degree the LCM of the local degrees.
nfhilbert	entity.name.function	nfhilbert(nf,a,b,{pr}): if pr is omitted, global Hilbert symbol (a,b) in nf, that is 1 if X^2-aY^2-bZ^2 has a nontrivial solution (X,Y,Z) in nf, -1 otherwise. Otherwise compute the local symbol modulo the prime ideal pr.
nfhnf	entity.name.function	nfhnf(nf,x,{flag=0}): if x=[A,I], gives a pseudo-basis [B,J] of the module sum A_jI_j. If flag is nonzero, return [[B,J], U], where U is the transformation matrix such that AU = [0|B].
nfhnfmod	entity.name.function	nfhnfmod(nf,x,detx): if x=[A,I], and detx is a multiple of the ideal determinant of x, gives a pseudo-basis of the module sum A_jI_j.
nfinit	entity.name.function	nfinit(pol,{flag=0}): pol being a nonconstant irreducible polynomial in Q[X], returns an nf structure attached to the number field Q[X] / (pol). Binary digits of flag mean 1: two-element vector [nf,Mod(a,P)], where Mod(a,P) is a polmod equal to Mod(x,pol) and P=nf.pol; 2: first use polredbest to find a simpler polynomial P; 4: do not LLL-reduce the maximal order basis nf.zk.
nfisideal	entity.name.function	nfisideal(nf,x): true(1) if x is an ideal in the number field nf, false(0) if not.
nfisincl	entity.name.function	nfisincl(f,g,{flag=0}): let f and g define number fields, either irreducible rational polynomials or number fields as output by nfinit; tests whether the number field f is isomorphic to a subfield of g. Return 0 if not, and otherwise all the embeddings (flag=0, default), only one (flag=1), or all embeddings as rational functions (flag=2).
nfisisom	entity.name.function	nfisisom(f,g): as nfisincl but tests whether f is isomorphic to g.
nfislocalpower	entity.name.function	nfislocalpower(nf,pr,a,n): true(1) if a is an n-th power in the local field K_v, false(0) if not.
nfkermodpr	entity.name.function	nfkermodpr(nf,x,pr): this function is obsolete, use nfmodpr.
nflist	entity.name.function	nflist(G, {N}, {s = -1}, {F}): find number fields (up to isomorphism) with Galois group of Galois closure isomorphic to G, and s complex places. If s = -1 (default) all signatures, s = -2 is identical to s = -1 except signatures are separated by increasing number of complex places. If field F is specified (by a polynomial), give only number fields having F as a subfield (or a resolvent field in the case of S3, Dl, A4, S4, F5, M21 and M42). The parameter N can be the following: a positive integer (absolute value of discriminant is N); a vector [a,b] (find fields with absolute discriminant between a and b); a polynomial, in variable t say (regular extension of Q(t) with specified Galois group). Finally, N can be omitted (default), in which case a few fields are given and F is ignored.
nfmodpr	entity.name.function	nfmodpr(nf,x,pr): map x to the residue field mod pr.
nfmodprinit	entity.name.function	nfmodprinit(nf,pr, {v = variable(nf.pol)}): transform the prime ideal pr into modpr format necessary for all operations mod pr in the number field nf. Variable v is used to display finite field elements (see ffgen).
nfmodprlift	entity.name.function	nfmodprlift(nf,x,pr): lift x from residue field mod pr to nf.
nfnewprec	entity.name.function	nfnewprec(nf): transform the number field data nf into new data using the current (usually larger) precision.
nfpolsturm	entity.name.function	nfpolsturm(nf, T, {pl}): number of distinct real roots of the polynomial s(T) where s runs through the real embeddings given by vector pl.
nfresolvent	entity.name.function	nfresolvent(pol,{flag=0}): In the case where the Galois closure of the number field defined by pol is S3, Dl, A4, S4, F5, A5, M21, or M42, give the corresponding resolvent field. Otherwise, give a "canonical" subfield, or if flag >= 2 all "canonical" subfields. If flag is odd, give also the "conductor" f, whose definition is specific to each group.
nfroots	entity.name.function	nfroots({nf},x): roots of polynomial x belonging to nf (Q if omitted) without multiplicity.
nfrootsof1	entity.name.function	nfrootsof1(nf): number of roots of unity and primitive root of unity in the number field nf.
nfsnf	entity.name.function	nfsnf(nf,x,{flag=0}): if x=[A,I,J], outputs D=[d_1,...d_n] Smith normal form of x. If flag is nonzero return [D,U,V], where UAV = Id.
nfsolvemodpr	entity.name.function	nfsolvemodpr(nf,a,b,P): this function is obsolete, use nfmodpr.
nfsplitting	entity.name.function	nfsplitting(P,{d},{fl}): defining polynomial S over Q for the splitting field of P, that is the smallest field over which P is totally split. P can also be given by a nf structure. If d is given, it must be a multiple of the splitting field degree. If fl=1, return [S,C] where C is an embedding of Q[x]/(P) in its splitting field.
nfsubfields	entity.name.function	nfsubfields(pol,{d=0},{fl=0}): find all subfields of degree d of number field defined by pol (all subfields if d is null or omitted). Result is a vector of subfields, each being given by [g,h] (default) or simply g (flag=1), where g is an absolute equation and h expresses one of the roots of g in terms of the root x of the polynomial defining nf.
nfsubfieldscm	entity.name.function	nfsubfieldscm(nf,{fl=0}): compute the maximal CM subfield of nf. Return 0 if nf does not have a CM subfield, otherwise return [g,h] (default) or g (fl=1) where g is an absolute equation and h expresses a root of g in terms of the generator of nf.
nfsubfieldsmax	entity.name.function	nfsubfieldsmax(nf,{fl=0}): compute the list of maximal subfields of nf. Result is as in nfsubfields.
norm	entity.name.function	norm(x): norm of x.
norml2	entity.name.function	norml2(x): square of the L2-norm of x.
normlp	entity.name.function	normlp(x,{p=oo}): Lp-norm of x; sup norm if p is omitted.
numbpart	entity.name.function	numbpart(n): number of partitions of n.
numdiv	entity.name.function	numdiv(x): number of divisors of x.
numerator	entity.name.function	numerator(f,{D}): numerator of f.
numtoperm	entity.name.function	numtoperm(n,k): permutation number k (mod n!) of n letters (n C-integer).
omega	entity.name.function	omega(x): number of distinct prime divisors of x.
oo	constant.language	oo=oo(): infinity.
padicappr	entity.name.function	padicappr(pol,a): p-adic roots of the polynomial pol congruent to a mod p.
padicfields	entity.name.function	padicfields(p, N, {flag=0}): returns polynomials generating all the extensions of degree N of the field of p-adic rational numbers; N is allowed to be a 2-component vector [n,d], in which case, returns the extensions of degree n and discriminant p^d. flag is optional, and can be 0: default, 1: return also the ramification index, the residual degree, the valuation of the discriminant and the number of conjugate fields, or 2: return only the number of extensions in a fixed algebraic closure.
padicprec	entity.name.function	padicprec(x,p): return the absolute p-adic precision of object x.
parapply	entity.name.function	parapply(f, x): parallel evaluation of f on the elements of x.
pareval	entity.name.function	pareval(x): parallel evaluation of the elements of the vector of closures x.
parfor	keyword.control	parfor(i=a,{b},expr1,{r},{expr2}): evaluates the expression expr1 in parallel for all i between a and b (if b is set to +oo, the loop will not stop), resulting in as many values; if the formal variables r and expr2 are present, evaluate sequentially expr2, in which r has been replaced by the different results obtained for expr1 and i with the corresponding arguments.
parforeach	keyword.control	parforeach(V,x,expr1,{r},{expr2}): evaluates in parallel the expression expr1 for all components x of V. If the formal variables r and expr2 are present, evaluate sequentially expr2, in which x and r are replaced by the successive arguments and corresponding values.
parforprime	keyword.control	parforprime(p=a,{b},expr1,{r},{expr2}): evaluates the expression expr1 in parallel for all primes p between a and b (if b is set to +oo, the loop will not stop), resulting in as many values; if the formal variables r and expr2 are present, evaluate sequentially expr2, in which r has been replaced by the different results obtained for expr1 and p with the corresponding arguments.
parforprimestep	keyword.control	parforprimestep(p=a,{b},q,expr1,{r},{expr2}): evaluates the expression expr1 in parallel for all primes p between a and b in an arithmetic progression of the form a + k*q, resulting in as many values; if the formal variables r and expr2 are present, evaluate sequentially expr2, in which r has been replaced by the different results obtained for expr1 and p with the corresponding arguments.
parforvec	keyword.control	parforvec(X=v,expr1,{j},{expr2},{flag}): evaluates the sequence expr2 (dependent on X and j) for X as generated by forvec, in random order, computed in parallel. Substitute for j the value of expr1 (dependent on X).
parploth	keyword.control	parploth(X=a,b,expr,{flags=0},{n=0}): parallel version of ploth. Plot of expression expr, X goes from a to b in high resolution. Both flags and n are optional. Binary digits of flags mean: 1=Parametric, 2=Recursive, 4=no_Rescale, 8=no_X_axis, 16=no_Y_axis, 32=no_Frame, 64=no_Lines (do not join points), 128=Points_too (plot both lines and points), 256=Splines (use cubic splines), 512=no_X_ticks, 1024= no_Y_ticks, 2048=Same_ticks (plot all ticks with the same length), 4096=Complex (the two coordinates of each point are encoded as a complex number). n specifies number of reference points on the graph (0=use default value). Returns a vector for the bounding box.
parplothexport	keyword.control	parplothexport(fmt, X=a,b,expr,{flags=0},{n=0}): parallel version of plothexport. Plot of expression expr, X goes from a to b in high resolution, returning the resulting picture as a character string which can then be written to a file.
parselect	entity.name.function	parselect(f, A, {flag = 0}): (parallel select) selects elements of A according to the selection function f which is tested in parallel. If flag is 1, return the indices of those elements (indirect selection).
parsum	keyword.control	parsum(i=a,b,expr): the sum (i goes from a to b) of expression expr, evaluated in parallel (in random order).
partitions	entity.name.function	partitions(k,{a=k},{n=k}): vector of partitions of the integer k. You can restrict the length of the partitions with parameter n (n=nmax or n=[nmin,nmax]), or the range of the parts with parameter a (a=amax or a=[amin,amax]). By default remove zeros, but one can set amin=0 to get X of fixed length nmax (=k by default).
parvector	keyword.control	parvector(N,i,expr): as vector(N,i,expr) but the evaluations of expr are done in parallel.
permcycles	entity.name.function	permcycles(x): cycles of the permutation x.
permorder	entity.name.function	permorder(x): order of the permutation x.
permsign	entity.name.function	permsign(x): signature of the permutation x.
permtonum	entity.name.function	permtonum(x): ordinal (between 0 and n!-1) of permutation x.
plot	keyword.control	plot(X=a,b,expr,{Ymin},{Ymax}): crude plot of expression expr, X goes from a to b, with Y ranging from Ymin to Ymax. If Ymin (resp. Ymax) is not given, the minimum (resp. the maximum) of the expression is used instead.
plotbox	entity.name.function	plotbox(w,x2,y2,{filled=0}): if the cursor is at position (x1,y1), draw a box with diagonal (x1,y1) and (x2,y2) in rectwindow w (cursor does not move). If filled=1, fill the box.
plotclip	entity.name.function	plotclip(w): clip the contents of the rectwindow to the bounding box (except strings).
plotcolor	entity.name.function	plotcolor(w,c): in rectwindow w, set default color to c. Possible values for c are [R,G,B] values, a color name or an index in the graphcolormap default: factory settings are 1=black, 2=blue, 3=sienna, 4=red, 5=green, 6=grey, 7=gainsborough. Return [R,G,B] value attached to color.
plotcopy	entity.name.function	plotcopy(sourcew,destw,dx,dy,{flag=0}): copy the contents of rectwindow sourcew to rectwindow destw with offset (dx,dy). If flag's bit 1 is set, dx and dy express fractions of the size of the current output device, otherwise dx and dy are in pixels. dx and dy are relative positions of northwest corners if other bits of flag vanish, otherwise of: 2: southwest, 4: southeast, 6: northeast corners.
plotcursor	entity.name.function	plotcursor(w): current position of cursor in rectwindow w.
plotdraw	entity.name.function	plotdraw(w, {flag=0}): draw rectwindow w. More generally, w can be of the form [w1,x1,y1, w2,x2,y2,etc.]: draw rectwindows wi at given xi,yi positions. If flag!=0, the xi,yi express fractions of the size of the current output device.
plotexport	entity.name.function	plotexport(fmt, list, {flag=0}): draw vector of rectwindows list as in plotdraw, returning the resulting picture as a character string; fmt is either "ps" or "svg".
ploth	keyword.control	ploth(X=a,b,expr,{flag=0},{n=0}): plot of expression expr, X goes from a to b in high resolution. Both flag and n are optional. Binary digits of flag mean: 1=Parametric, 2=Recursive, 4=no_Rescale, 8=no_X_axis, 16=no_Y_axis, 32=no_Frame, 64=no_Lines (do not join points), 128=Points_too (plot both lines and points), 256=Splines (use cubic splines), 512=no_X_ticks, 1024= no_Y_ticks, 2048=Same_ticks (plot all ticks with the same length), 4096=Complex (the two coordinates of each point are encoded as a complex number). n specifies number of reference points on the graph (0=use default value). Returns a vector for the bounding box.
plothexport	keyword.control	plothexport(fmt, X=a,b,expr,{flags=0},{n=0}): plot of expression expr, X goes from a to b in high resolution, returning the resulting picture as a character string which can then be written to a file.
plothraw	entity.name.function	plothraw(X,Y,{flag=0}): plot in high resolution points whose x (resp. y) coordinates are in X (resp. Y). If flag is 1, join points, other nonzero flags should be combinations of bits 8,16,32,64,128,256 meaning the same as for ploth().
plothrawexport	entity.name.function	plothrawexport(fmt, X,Y,{flag=0}): plot in high resolution points whose x (resp. y) coordinates are in X (resp. Y), returning the resulting picture as a character string. If flag is 1, join points, other nonzero flags should be combinations of bits 8,16,32,64,128,256 meaning the same as for ploth().
plothsizes	entity.name.function	plothsizes({flag=0}): returns array of 8 elements: terminal width and height, sizes for ticks in horizontal and vertical directions, width and height of characters, width and height of display (if applicable). If flag=0, sizes of ticks and characters are in pixels, otherwise are fractions of the terminal size.
plotinit	entity.name.function	plotinit(w,{x},{y},{flag=0}): initialize rectwindow w to size x,y. If flag!=0, x and y express fractions of the size of the current output device. Omitting x or y means use the full size of the device.
plotkill	entity.name.function	plotkill(w): erase the rectwindow w.
plotlines	entity.name.function	plotlines(w,X,Y,{flag=0}): draws an open polygon in rectwindow w where X and Y contain the x (resp. y) coordinates of the vertices. If X and Y are both single values (i.e not vectors), draw the corresponding line (and move cursor). If (optional) flag is nonzero, close the polygon.
plotlinetype	entity.name.function	plotlinetype(w,type): this function is obsolete; no graphing engine implement this functionality.
plotmove	entity.name.function	plotmove(w,x,y): move cursor to position x,y in rectwindow w.
plotpoints	entity.name.function	plotpoints(w,X,Y): draws in rectwindow w the points whose x (resp y) coordinates are in X (resp Y). If X and Y are both single values (i.e not vectors), draw the corresponding point (and move cursor).
plotpointsize	entity.name.function	plotpointsize(w,size): change the "size" of following points in rectwindow w. w=-1 changes global value.
plotpointtype	entity.name.function	plotpointtype(w,type): this function is obsolete; no graphing engine implement this functionality.
plotrbox	entity.name.function	plotrbox(w,dx,dy,{filled}): if the cursor is at (x1,y1), draw a box with diagonal (x1,y1)-(x1+dx,y1+dy) in rectwindow w (cursor does not move). If filled=1, fill the box.
plotrecth	keyword.control	plotrecth(w,X=a,b,expr,{flag=0},{n=0}): writes to rectwindow w the curve output of ploth(w,X=a,b,expr,flag,n). Returns a vector for the bounding box.
plotrecthraw	entity.name.function	plotrecthraw(w,data,{flags=0}): plot graph(s) for data in rectwindow w, where data is a vector of vectors. If plot is parametric, length of data should be even, and pairs of entries give curves to plot. If not, first entry gives x-coordinate, and the other ones y-coordinates. Admits the same optional flags as plotrecth, save that recursive plot is meaningless.
plotrline	entity.name.function	plotrline(w,dx,dy): if the cursor is at (x1,y1), draw a line from (x1,y1) to (x1+dx,y1+dy) (and move the cursor) in the rectwindow w.
plotrmove	entity.name.function	plotrmove(w,dx,dy): move cursor to position (dx,dy) relative to the present position in the rectwindow w.
plotrpoint	entity.name.function	plotrpoint(w,dx,dy): draw a point (and move cursor) at position dx,dy relative to present position of the cursor in rectwindow w.
plotscale	entity.name.function	plotscale(w,x1,x2,y1,y2): scale the coordinates in rectwindow w so that x goes from x1 to x2 and y from y1 to y2 (y2<y1 is allowed).
plotstring	entity.name.function	plotstring(w,x,{flags=0}): draw in rectwindow w the string corresponding to x. Bits 1 and 2 of flag regulate horizontal alignment: left if 0, right if 2, center if 1. Bits 4 and 8 regulate vertical alignment: bottom if 0, top if 8, v-center if 4. Can insert additional gap between point and string: horizontal if bit 16 is set, vertical if bit 32 is set.
polchebyshev	entity.name.function	polchebyshev(n,{flag=1},{a='x}): Chebyshev polynomial of the first (flag = 1) or second (flag = 2) kind, of degree n, evaluated at a.
polclass	entity.name.function	polclass(D, {inv = 0}, {x = 'x}): return a polynomial generating the Hilbert class field of Q(sqrt(D)) for the discriminant D<0.
polcoef	entity.name.function	polcoef(x,n,{v}): coefficient of degree n of x. With respect to the main variable if v is omitted, with respect to the variable v otherwise.
polcoeff	entity.name.function	polcoeff(x,n,{v}): deprecated alias for polcoef.
polcompositum	entity.name.function	polcompositum(P,Q,{flag=0}): vector of all possible compositums of the number fields defined by the polynomials P and Q; flag is optional, whose binary digits mean 1: output for each compositum, not only the compositum polynomial pol, but a vector [R,a,b,k] where a (resp. b) is a root of P (resp. Q) expressed as a polynomial modulo R, and a small integer k such that al2+k*al1 is the chosen root of R; 2: assume that the number fields defined by P and Q are linearly disjoint.
polcyclo	entity.name.function	polcyclo(n,{a = 'x}): n-th cyclotomic polynomial evaluated at a.
polcyclofactors	entity.name.function	polcyclofactors(f): returns a vector of polynomials, whose product is the product of distinct cyclotomic polynomials dividing f.
poldegree	entity.name.function	poldegree(x,{v}): degree of the polynomial or rational function x with respect to main variable if v is omitted, with respect to v otherwise. For scalar x, return 0 if x is nonzero and -oo otherwise.
poldisc	entity.name.function	poldisc(pol,{v}): discriminant of the polynomial pol, with respect to main variable if v is omitted, with respect to v otherwise.
poldiscfactors	entity.name.function	poldiscfactors(T,{flag=0}): [D, faD], where D = discriminant of the polynomial T, and faD is a cheap partial factorization of D (entries are coprime but need not be primes); if flag is 1, finish the factorization via factorint.
poldiscreduced	entity.name.function	poldiscreduced(f): vector of elementary divisors of Z[a]/f'(a)Z[a], where a is a root of the polynomial f.
polgalois	entity.name.function	polgalois(T): Galois group of the polynomial T (see manual for group coding). Return [n, s, k, name] where n is the group order, s the signature, k the index and name is the GAP4 name of the transitive group.
polgraeffe	entity.name.function	polgraeffe(f): returns the Graeffe transform g of f, such that g(x^2) = f(x)f(-x).
polhensellift	entity.name.function	polhensellift(A, B, p, e): lift the factorization B of A modulo p to a factorization modulo p^e using Hensel lift. The factors in B must be pairwise relatively prime modulo p.
polhermite	entity.name.function	polhermite(n,{a='x},{flag=0}): Hermite polynomial H(n,v) of degree n, evaluated at a. If flag is nonzero, return [H_{n-1}(a), H_n(a)].
polinterpolate	entity.name.function	polinterpolate(X,{Y},{t = 'x},{&e}): polynomial interpolation at t according to data vectors X, Y, i.e., given P of minimal degree such that P(X[i]) = Y[i] for all i, return P(t). If Y is omitted, take P such that P(i) = X[i]. If present and t is numeric, e will contain an error estimate on the returned value (Neville's algorithm).
poliscyclo	entity.name.function	poliscyclo(f): returns 0 if f is not a cyclotomic polynomial, and n > 0 if f = Phi_n, the n-th cyclotomic polynomial.
poliscycloprod	entity.name.function	poliscycloprod(f): returns 1 if f is a product of cyclotomic polynonials, and 0 otherwise.
polisirreducible	entity.name.function	polisirreducible(pol): true(1) if pol is an irreducible nonconstant polynomial, false(0) if pol is reducible or constant.
pollaguerre	entity.name.function	pollaguerre(n,{a=0},{b='x},{flag=0}): Laguerre polynomial of degree n and parameter a evaluated at b. If flag is 1, return [L^{(a)_{n-1}(b), L^{(a)}_n(b)].
pollead	entity.name.function	pollead(x,{v}): leading coefficient of polynomial or series x, or x itself if x is a scalar. Error otherwise. With respect to the main variable of x if v is omitted, with respect to the variable v otherwise.
pollegendre	entity.name.function	pollegendre(n,{a='x},{flag=0}): legendre polynomial of degree n evaluated at a. If flag is 1, return [P_{n-1}(a), P_n(a)].
polmodular	entity.name.function	polmodular(L, {inv = 0}, {x = 'x}, {y = 'y}, {derivs = 0}): return the modular polynomial of level L and invariant inv.
polrecip	entity.name.function	polrecip(pol): reciprocal polynomial of pol.
polred	entity.name.function	polred(T,{flag=0}): deprecated, use polredbest. Reduction of the polynomial T (gives minimal polynomials only). The following binary digits of (optional) flag are significant 1: partial reduction, 2: gives also elements.
polredabs	entity.name.function	polredabs(T,{flag=0}): a smallest generating polynomial of the number field for the T2 norm on the roots, with smallest index for the minimal T2 norm. flag is optional, whose binary digit mean 1: give the element whose characteristic polynomial is the given polynomial. 4: give all polynomials of minimal T2 norm (give only one of P(x) and P(-x)).
polredbest	entity.name.function	polredbest(T,{flag=0}): reduction of the polynomial T (gives minimal polynomials only). If flag=1, gives also elements.
polredord	entity.name.function	polredord(x): this function is obsolete, use polredbest.
polresultant	entity.name.function	polresultant(x,y,{v},{flag=0}): resultant of the polynomials x and y, with respect to the main variables of x and y if v is omitted, with respect to the variable v otherwise. flag is optional, and can be 0: default, uses either the subresultant algorithm, a modular algorithm or Sylvester's matrix, depending on the inputs; 1 uses Sylvester's matrix (should always be slower than the default).
polresultantext	entity.name.function	polresultantext(A,B,{v}): return [U,V,R] such that R=polresultant(A,B,v) and U*A+V*B = R, where A and B are polynomials.
polroots	entity.name.function	polroots(T): complex roots of the polynomial T using Schonhage's method, as modified by Gourdon.
polrootsbound	entity.name.function	polrootsbound(T, {tau = 0.01}): return a sharp upper bound for the modulus of the largest complex root of the polynomial T with relative error tau.
polrootsff	entity.name.function	polrootsff(x,{p},{a}): obsolete, use polrootsmod.
polrootsmod	entity.name.function	polrootsmod(f,{D}): roots of the polynomial f over the finite field defined by the domain D.
polrootspadic	entity.name.function	polrootspadic(f,p,r): p-adic roots of the polynomial f to precision r.
polrootsreal	entity.name.function	polrootsreal(T, {ab}): real roots of the polynomial T with real coefficients, using Uspensky's method. In interval ab = [a,b] if present.
polsturm	entity.name.function	polsturm(T,{ab}): number of distinct real roots of the polynomial T (in the interval ab = [a,b] if present).
polsubcyclo	entity.name.function	polsubcyclo(n,d,{v='x}): finds an equation (in variable v) for the d-th degree subfields of Q(zeta_n). Output is a polynomial, or a vector of polynomials if there are several such fields or none.
polsubcyclofast	entity.name.function	polsubcyclofast(n,d,{s=0},{exact=0}): If 1 <= d <= 6 or a prime, finds an equation for the subfields of Q(zeta_n) with galois group C_d. Contrary to polsubcyclo, the output is always a (possibly empty) vector of polynomials. If s = 0 (default) all signatures, otherwise s = 1 (resp., -1) for totally real (resp., totally complex). Set exact = 1 for subfields of exact conductor n.
polsylvestermatrix	entity.name.function	polsylvestermatrix(x,y): forms the sylvester matrix attached to the two polynomials x and y. Warning: the polynomial coefficients are in columns, not in rows.
polsym	entity.name.function	polsym(x,n): column vector of symmetric powers of the roots of x up to n.
poltchebi	entity.name.function	poltchebi(n,{v='x}): deprecated alias for polchebyshev.
polteichmuller	entity.name.function	polteichmuller(T,p,r): return the polynomial whose roots (resp. leading coef) are the Teichmuller lift of the roots (resp. leading coef) of T, to p-adic precision r.
poltomonic	entity.name.function	poltomonic(T,{&L}): T in Q[x]; return U monic in Z[x] such that U(x) = C T(x/L) for some rational C and L. If &L is given, set it to L.
poltschirnhaus	entity.name.function	poltschirnhaus(x): random Tschirnhausen transformation of the polynomial x.
polylog	entity.name.function	polylog(m,x,{flag=0}): m-th polylogarithm of x. flag is optional, and can be 0: default, 1: D_m~-modified m-th polylog of x, 2: D_m-modified m-th polylog of x, 3: P_m-modified m-th polylog of x.
polylogmult	entity.name.function	polylogmult(s,{z},{t=0}): multiple polylogarithm value at integral s = [s1,...,sr] with argument z = [z1,...,zr]. If z is omitted, assume z = [1,...,1], i.e., multiple zeta value. More generally, return Yamamoto's interpolation at t (ordinary multiple polylog at t = 0 and star value at t = 1).
polzagier	entity.name.function	polzagier(n,m): Zagier's polynomials of index n,m.
powers	entity.name.function	powers(x,n,{x0}): return the vector [1,x,...,x^n] if x0 is omitted, and [x0, x0*x, ..., x0*x^n] otherwise.
precision	entity.name.function	precision(x,{n}): if n is present, return x at precision n. If n is omitted, return real precision of object x.
precprime	entity.name.function	precprime(x): largest pseudoprime <= x, 0 if x<=1.
prime	entity.name.function	prime(n): returns the n-th prime (n C-integer).
primecert	entity.name.function	primecert(N, {flag=0}, {partial=0}): If N is a prime, return a Primality Certificate. Return 0 otherwise. If flag = 0 return an ECPP certificate (Atkin-Morain); if flag = 1 return an N-1 certificate (Pocklington-Lehmer)
primecertexport	entity.name.function	primecertexport(cert, {format = 0}): Returns a string suitable for print/write to display a primality certificate.
primecertisvalid	entity.name.function	primecertisvalid(cert): Verifies if cert is a valid PARI ECPP Primality certificate.
primepi	entity.name.function	primepi(x): the prime counting function pi(x) = #{p <= x, p prime}.
primes	entity.name.function	primes(n): returns the vector of the first n primes (integer), or the primes in interval n = [a,b].
print	entity.name.function	print({str}*): outputs its string arguments (in raw format) ending with a newline.
print1	entity.name.function	print1({str}*): outputs its string arguments (in raw format) without ending with newline.
printf	entity.name.function	printf(fmt,{x}*): prints its arguments according to the format fmt.
printp	entity.name.function	printp({str}*): outputs its string arguments (in prettymatrix format) ending with a newline.
printsep	entity.name.function	printsep(sep,{str}*): outputs its string arguments (in raw format), separated by 'sep', ending with a newline.
printsep1	entity.name.function	printsep1(sep,{str}*): outputs its string arguments (in raw format), separated by 'sep', without ending with a newline.
printtex	entity.name.function	printtex({str}*): outputs its string arguments in TeX format.
prod	keyword.control	prod(X=a,b,expr,{x=1}): x times the product (X runs from a to b) of expression.
prodeuler	keyword.control	prodeuler(p=a,b,expr): Euler product (p runs over the primes between a and b) of real or complex expression, as a floating point approximation.
prodeulerrat	entity.name.function	prodeulerrat(F,{s=1},{a=2}): product from primes p = a to infinity of F(p^s), where F is a rational function.
prodinf	keyword.control	prodinf(X=a,expr,{flag=0}): infinite product (X goes from a to infinity) of real or complex expression. flag can be 0 (default) or 1, in which case compute the product of the 1+expr instead.
prodnumrat	entity.name.function	prodnumrat(F,a): product from n = a to infinity of F(n), where F-1 is a rational function of degree less than or equal to -2.
psdraw	entity.name.function	psdraw(list, {flag=0}): obsolete function.
psi	entity.name.function	psi(x): psi-function at x.
psploth	keyword.control	psploth(X=a,b,expr,{flags=0},{n=0}): obsolete function.
psplothraw	entity.name.function	psplothraw(listx,listy,{flag=0}): obsolete function.
qfauto	entity.name.function	qfauto(G,{fl}): automorphism group of the positive definite quadratic form G.
qfautoexport	entity.name.function	qfautoexport(qfa,{flag}): qfa being an automorphism group as output by qfauto, output a string representing the underlying matrix group in GAP notation (default) or Magma notation (flag = 1).
qfbclassno	entity.name.function	qfbclassno(D,{flag=0}): class number of discriminant D using Shanks's method by default. If (optional) flag is set to 1, use Euler products.
qfbcomp	entity.name.function	qfbcomp(x,y): Gaussian composition with reduction of the binary quadratic forms x and y.
qfbcompraw	entity.name.function	qfbcompraw(x,y): Gaussian composition without reduction of the binary quadratic forms x and y.
qfbcornacchia	entity.name.function	qfbcornacchia(d,n): Solve the equation x^2+dy^2 = n in integers x and y where d > 0 and n is prime or 4 times a prime.
qfbhclassno	entity.name.function	qfbhclassno(x): Hurwitz-Kronecker class number of x>0.
qfbil	entity.name.function	qfbil(x,y,{q}): this function is obsolete, use qfeval.
qfbnucomp	entity.name.function	qfbnucomp(x,y,L): composite of primitive positive definite quadratic forms x and y using nucomp and nudupl, where L=[|D/4|^(1/4)] is precomputed.
qfbnupow	entity.name.function	qfbnupow(x,n,{L}): n-th power of primitive positive definite quadratic form x using nucomp and nudupl.
qfbpow	entity.name.function	qfbpow(x,n): n-th power with reduction of the binary quadratic form x.
qfbpowraw	entity.name.function	qfbpowraw(x,n): n-th power without reduction of the binary quadratic form x.
qfbprimeform	entity.name.function	qfbprimeform(x,p): returns the prime form of discriminant x, whose first coefficient is p.
qfbred	entity.name.function	qfbred(x,{flag=0},{isd},{sd}): reduction of the binary quadratic form x. All other args. are optional. The argument isd and sd, if present, supply the values of floor(sqrt(d)) and sqrt(d) respectively, where d is the discriminant. If d<0, its value is not used. flag can be any of 0: default; 1: do a single reduction step;
qfbredsl2	entity.name.function	qfbredsl2(x,{isD}): reduction of the binary quadratic form x, return [y,g] where y is reduced and g in Sl(2,Z) is such that g.x = y; isD, if present, must be equal to sqrtint(D), where D > 0 is the discriminant of x.
qfbsolve	entity.name.function	qfbsolve(Q,n,{flag=0}): Solve the equation Q(x,y)=n in coprime integers x and y where Q is a binary quadratic form, up to the action of the special orthogonal group of Q over the integers. Binary digits of flag mean 1: return all solutions, 2: also include imprimitive solutions.
qfeval	entity.name.function	qfeval({q},x,{y}): evaluate the quadratic form q (symmetric matrix) at x; if y is present, evaluate the polar form at (x,y); if q omitted, use the standard Euclidean form.
qfgaussred	entity.name.function	qfgaussred(q): square reduction of the (symmetric) matrix q (returns a square matrix whose i-th diagonal term is the coefficient of the i-th square in which the coefficient of the i-th variable is 1).
qfisom	entity.name.function	qfisom(G,H,{fl},{grp}): find an isomorphism between the integral positive definite quadratic forms G and H if it exists. G can also be given by a qfisominit structure which is preferable if several forms need to be compared to G.
qfisominit	entity.name.function	qfisominit(G,{fl},{m}): G being a square and symmetric matrix representing an integral positive definite quadratic form, this function returns a structure allowing to compute isomorphisms between G and other quadratic form faster.
qfjacobi	entity.name.function	qfjacobi(A): eigenvalues and orthogonal matrix of eigenvectors of the real symmetric matrix A.
qflll	entity.name.function	qflll(x,{flag=0}): LLL reduction of the vectors forming the matrix x (gives the unimodular transformation matrix T such that x*T is LLL-reduced). flag is optional, and can be 0: default, 1: assumes x is integral, 2: assumes x is integral, returns a partially reduced basis, 4: assumes x is integral, returns [K,T] where K is the integer kernel of x and T the LLL reduced image, 5: same as 4 but x may have polynomial coefficients, 8: same as 0 but x may have polynomial coefficients.
qflllgram	entity.name.function	qflllgram(G,{flag=0}): LLL reduction of the lattice whose gram matrix is G (gives the unimodular transformation matrix). flag is optional and can be 0: default,1: assumes x is integral, 4: assumes x is integral, returns [K,T], where K is the integer kernel of x and T the LLL reduced image, 5: same as 4 but x may have polynomial coefficients, 8: same as 0 but x may have polynomial coefficients.
qfminim	entity.name.function	qfminim(x,{B},{m},{flag=0}): x being a square and symmetric matrix representing a positive definite quadratic form, this function deals with the vectors of x whose norm is less than or equal to B, enumerated using the Fincke-Pohst algorithm, storing at most m vectors (no limit if m is omitted). The function searches for the minimal nonzero vectors if B is omitted. The precise behavior depends on flag. 0: returns at most 2m vectors (unless m omitted), returns [N,M,V] where N is the number of vectors enumerated, M the maximum norm among these, and V lists half the vectors (the other half is given by -V). 1: ignores m and returns the first vector whose norm is less than B. 2: as 0 but uses a more robust, slower implementation
qfminimize	entity.name.function	qfminimize(G): given a square symmetric matrix G with rational coefficients and non-zero determinant, of dimension n >= 1, return [H,U] such that H = c * U~*G*U for some rational c, and H integral with minimal determinant.
qfnorm	entity.name.function	qfnorm(x,{q}): this function is obsolete, use qfeval.
qforbits	entity.name.function	qforbits(G,V): return the orbits of V under the action of the group of linear transformation generated by the set G, which must stabilize V.
qfparam	entity.name.function	qfparam(G, sol, {flag = 0}): coefficients of binary quadratic forms that parametrize the solutions of the ternary quadratic form G, using the particular solution sol.
qfperfection	entity.name.function	qfperfection(G): rank of matrix of xx~ for x minimal vectors of a Gram matrix G.
qfrep	entity.name.function	qfrep(q,B,{flag=0}): vector of (half) the number of vectors of norms from 1 to B for the integral and definite quadratic form q. If flag is 1, count vectors of even norm from 1 to 2B.
qfsign	entity.name.function	qfsign(x): signature of the symmetric matrix x.
qfsolve	entity.name.function	qfsolve(G): solve over Q the quadratic equation X^t G X = 0, where G is a symmetric matrix.
quadclassunit	entity.name.function	quadclassunit(D,{flag=0},{tech=[]}): compute the structure of the class group and the regulator of the quadratic field of discriminant D. See manual for the optional technical parameters.
quaddisc	entity.name.function	quaddisc(x): discriminant of the quadratic field Q(sqrt(x)).
quadgen	entity.name.function	quadgen(D,{v = 'w}): standard generator g of quadratic order of discriminant D. If v is given, the variable name is used to display g, else 'w' is used.
quadhilbert	entity.name.function	quadhilbert(D): relative equation for the Hilbert class field of the quadratic field of discriminant D (which can also be a bnf).
quadpoly	entity.name.function	quadpoly(D,{v='x}): quadratic polynomial corresponding to the discriminant D, in variable v.
quadray	entity.name.function	quadray(D,f): relative equation for the ray class field of conductor f for the quadratic field of discriminant D (which can also be a bnf).
quadregulator	entity.name.function	quadregulator(D): regulator of the real quadratic field of discriminant D.
quadunit	entity.name.function	quadunit(D,{v = 'w}): fundamental unit u of the quadratic order of discriminant D where D must be positive. If v is given, the variable name is used to display u, else 'w' is used.
quadunitindex	entity.name.function	quadunitindex(D, f): given a fundamental discriminant D, return the index of the unit group of the order of conductor f.
quadunitnorm	entity.name.function	quadunitnorm(D): return the norm of the fundamental unit of the quadratic order of discriminant D.
quit	keyword.control	quit({status = 0}): quit, return to the system with exit status 'status'.
ramanujantau	entity.name.function	ramanujantau(n,{ell=12}): compute the value of Ramanujan's tau function at n, assuming the GRH. If ell is 16, 18, 20, 22, or 26, same for the newform of level 1 and corresponding weight. Otherwise, compute the coefficient of the trace form at n. Algorithm in O(n^{1/2+eps}).
random	entity.name.function	random({N=2^31}): random object, depending on the type of N. Integer between 0 and N-1 (t_INT), int mod N (t_INTMOD), element in a finite field (t_FFELT), point on an elliptic curve (ellinit mod p or over a finite field).
randomprime	entity.name.function	randomprime({N = 2^31}, {q}): returns a strong pseudo prime in [2, N-1]. If q is an integer, return a prime = 1 mod q; if q is an intmod, return a prime in the given congruence class.
read	entity.name.function	read({filename}): read from the input file filename. If filename is omitted, reread last input file, be it from read() or \r.
readstr	entity.name.function	readstr({filename}): returns the vector of GP strings containing the lines in filename.
readvec	entity.name.function	readvec({filename}): create a vector whose components are the evaluation of all the expressions found in the input file filename.
real	entity.name.function	real(x): real part of x.
removeprimes	entity.name.function	removeprimes({x=[]}): remove primes in the vector x from the prime table. x can also be a single integer. List the current extra primes if x is omitted.
return	keyword.control	return({x=0}): return from current subroutine with result x.
rnfalgtobasis	entity.name.function	rnfalgtobasis(rnf,x): relative version of nfalgtobasis, where rnf is a relative numberfield.
rnfbasis	entity.name.function	rnfbasis(bnf,M): given a projective Z_K-module M as output by rnfpseudobasis or rnfsteinitz, gives either a basis of M if it is free, or an n+1-element generating set.
rnfbasistoalg	entity.name.function	rnfbasistoalg(rnf,x): relative version of nfbasistoalg, where rnf is a relative numberfield.
rnfcharpoly	entity.name.function	rnfcharpoly(nf,T,a,{var='x}): characteristic polynomial of a over nf, where a belongs to the algebra defined by T over nf. Returns a polynomial in variable var (x by default).
rnfconductor	entity.name.function	rnfconductor(bnf,T,{flag=0}): conductor of the Abelian extension of bnf defined by T. The result is [conductor,bnr,subgroup], where conductor is the conductor itself, bnr the attached bnr structure, and subgroup the HNF defining the norm group (Artin or Takagi group) on the given generators bnr.gen. If flag is 1, return a bnr modulo deg(T), attached to Cl_f / (deg(T)); if flag is 2 only return [f, idealfactor(f[1])].
rnfdedekind	entity.name.function	rnfdedekind(nf,pol,{pr},{flag=0}): relative Dedekind criterion over the number field K, represented by nf, applied to the order O_K[X]/(P), modulo the prime ideal pr (at all primes if pr omitted, in which case flag is automatically set to 1). P is assumed to be monic, irreducible, in O_K[X]. Returns [max,basis,v], where basis is a pseudo-basis of the enlarged order, max is 1 iff this order is pr-maximal, and v is the valuation at pr of the order discriminant. If flag is set, just return 1 if the order is maximal, and 0 if not.
rnfdet	entity.name.function	rnfdet(nf,M): given a pseudo-matrix M, compute its determinant.
rnfdisc	entity.name.function	rnfdisc(nf,T): given a polynomial T with coefficients in nf, gives a 2-component vector [D,d], where D is the relative ideal discriminant, and d is the relative discriminant in nf^*/nf*^2.
rnfeltabstorel	entity.name.function	rnfeltabstorel(rnf,x): transforms the element x from absolute to relative representation.
rnfeltdown	entity.name.function	rnfeltdown(rnf,x,{flag=0}): expresses x on the base field if possible; returns an error otherwise.
rnfeltnorm	entity.name.function	rnfeltnorm(rnf,x): returns the relative norm N_{L/K}(x), as an element of K.
rnfeltreltoabs	entity.name.function	rnfeltreltoabs(rnf,x): transforms the element x from relative to absolute representation.
rnfelttrace	entity.name.function	rnfelttrace(rnf,x): returns the relative trace Tr_{L/K}(x), as an element of K.
rnfeltup	entity.name.function	rnfeltup(rnf,x,{flag=0}): expresses x (belonging to the base field) on the relative field. As a t_POLMOD if flag = 0 and as a t_COL on the absolute field integer basis if flag = 1.
rnfequation	entity.name.function	rnfequation(nf,pol,{flag=0}): given a pol with coefficients in nf, gives an absolute equation z of the number field defined by pol. flag is optional, and can be 0: default, or nonzero, gives [z,al,k], where z defines the absolute equation L/Q as in the default behavior, al expresses as an element of L a root of the polynomial defining the base field nf, and k is a small integer such that t = b + k al is a root of z, for b a root of pol.
rnfhnfbasis	entity.name.function	rnfhnfbasis(bnf,M): given a bnf attached to a number field K and a projective Z_K module M given by a pseudo-matrix, returns either a true HNF basis of M if one exists, or zero otherwise. If M is a polynomial with coefficients in K, replace it by the pseudo-matrix returned by rnfpseudobasis.
rnfidealabstorel	entity.name.function	rnfidealabstorel(rnf,x): transforms the ideal x from absolute to relative representation.
rnfidealdown	entity.name.function	rnfidealdown(rnf,x): finds the intersection of the ideal x with the base field.
rnfidealfactor	entity.name.function	rnfidealfactor(rnf,x): factor the ideal x into prime ideals in the number field nfinit(rnf).
rnfidealhnf	entity.name.function	rnfidealhnf(rnf,x): relative version of idealhnf, where rnf is a relative numberfield.
rnfidealmul	entity.name.function	rnfidealmul(rnf,x,y): relative version of idealmul, where rnf is a relative numberfield.
rnfidealnormabs	entity.name.function	rnfidealnormabs(rnf,x): absolute norm of the ideal x.
rnfidealnormrel	entity.name.function	rnfidealnormrel(rnf,x): relative norm of the ideal x.
rnfidealprimedec	entity.name.function	rnfidealprimedec(rnf,pr): return prime ideal decomposition of the maximal ideal pr of K in L/K; pr is also allowed to be a prime number p, in which case return a pair of vectors [SK,SL], where SK contains the primes of K above p and SL[i] is the vector of primes of L above SK[i].
rnfidealreltoabs	entity.name.function	rnfidealreltoabs(rnf,x,{flag=0}): transforms the ideal x from relative to absolute representation. As a vector of t_POLMODs if flag = 0 and as an ideal in HNF in the absolute field if flag = 1.
rnfidealtwoelt	entity.name.function	rnfidealtwoelt(rnf,x): relative version of idealtwoelt, where rnf is a relative numberfield.
rnfidealup	entity.name.function	rnfidealup(rnf,x,{flag=0}): lifts the ideal x (of the base field) to the relative field. As a vector of t_POLMODs if flag = 0 and as an ideal in HNF in the absolute field if flag = 1.
rnfinit	entity.name.function	rnfinit(nf,T,{flag=0}): T being an irreducible polynomial defined over the number field nf, initializes a vector of data necessary for working in relative number fields (rnf functions). See manual for technical details.
rnfisabelian	entity.name.function	rnfisabelian(nf,T): T being a relative polynomial with coefficients in nf, return 1 if it defines an abelian extension, and 0 otherwise.
rnfisfree	entity.name.function	rnfisfree(bnf,M): given a bnf attached to a number field K and a projective Z_K module M given by a pseudo-matrix, return true (1) if M is free else return false (0).
rnfislocalcyclo	entity.name.function	rnfislocalcyclo(rnf): true(1) if the l-extension attached to rnf is locally cyclotomic (locally contained in the Z_l extension of K_v at all places v | l), false(0) if not.
rnfisnorm	entity.name.function	rnfisnorm(T,a,{flag=0}): T is as output by rnfisnorminit applied to L/K. Tries to tell whether a is a norm from L/K. Returns a vector [x,q] where a=Norm(x)*q. Looks for a solution which is a S-integer, with S a list of places in K containing the ramified primes, generators of the class group of ext, as well as those primes dividing a. If L/K is Galois, you may omit flag, otherwise it is used to add more places to S: all the places above the primes p <= flag (resp. p | flag) if flag > 0 (resp. flag < 0). The answer is guaranteed (i.e a is a norm iff q=1) if L/K is Galois or, under GRH, if S contains all primes less than 12.log(disc(M))^2, where M is the normal closure of L/K.
rnfisnorminit	entity.name.function	rnfisnorminit(pol,polrel,{flag=2}): let K be defined by a root of pol, L/K the extension defined by polrel. Compute technical data needed by rnfisnorm to solve norm equations Nx = a, for x in L, and a in K. If flag=0, do not care whether L/K is Galois or not; if flag = 1, assume L/K is Galois; if flag = 2, determine whether L/K is Galois.
rnfkummer	entity.name.function	rnfkummer(bnr,{subgp}): this function is deprecated. Use bnrclassfield.
rnflllgram	entity.name.function	rnflllgram(nf,pol,order): given a pol with coefficients in nf and an order as output by rnfpseudobasis or similar, gives [[neworder],U], where neworder is a reduced order and U is the unimodular transformation matrix.
rnfnormgroup	entity.name.function	rnfnormgroup(bnr,pol): norm group (or Artin or Takagi group) corresponding to the Abelian extension of bnr.bnf defined by pol, where the module corresponding to bnr is assumed to be a multiple of the conductor. The result is the HNF defining the norm group on the generators in bnr.gen.
rnfpolred	entity.name.function	rnfpolred(nf,pol): given a pol with coefficients in nf, finds a list of relative polynomials defining some subfields, hopefully simpler.
rnfpolredabs	entity.name.function	rnfpolredabs(nf,pol,{flag=0}): given an irreducible pol with coefficients in nf, finds a canonical relative polynomial defining the same field. Binary digits of flag mean: 1: return also the element whose characteristic polynomial is the given polynomial, 2: return an absolute polynomial, 16: partial reduction.
rnfpolredbest	entity.name.function	rnfpolredbest(nf,pol,{flag=0}): given a pol with coefficients in nf, finds a relative polynomial P defining the same field, hopefully simpler than pol; flag can be 0: default, 1: return [P,a], where a is a root of pol 2: return an absolute polynomial Pabs, 3: return [Pabs, a,b], where a is a root of nf.pol and b is a root of pol.
rnfpseudobasis	entity.name.function	rnfpseudobasis(nf,T): given an irreducible polynomial T with coefficients in nf, returns [A,J,D,d] where [A,J] is a pseudo basis of the maximal order of the extension, D is the relative ideal discriminant, and d is the relative discriminant in nf^*/nf*^2.
rnfsteinitz	entity.name.function	rnfsteinitz(nf,M): given a nf attached to a number field K and a projective module M given by a pseudo-matrix, returns [A,I,D,d] where (A,I) is a pseudo basis for M where all the ideals except perhaps the last are trivial. If M is a polynomial with coefficients in K, replace it by the pseudo-matrix returned by rnfpseudobasis.
rootsof1	entity.name.function	rootsof1(N): column vector of complex N-th roots of 1.
round	entity.name.function	round(x,{&e}): take the nearest integer to all the coefficients of x. If e is present, do not take into account loss of integer part precision, and set e = error estimate in bits.
select	entity.name.function	select(f, A, {flag = 0}): selects elements of A according to the selection function f. If flag is 1, return the indices of those elements (indirect selection).
self	entity.name.function	self(): return the calling function or closure. Useful for defining anonymous recursive functions.
seralgdep	entity.name.function	seralgdep(s,p,r): find a linear relation between powers (1,s, ..., s^p) of the series s, with polynomial coefficients of degree <= r.
serchop	entity.name.function	serchop(s,{n=0}): remove all terms of degree strictly less than n in series s.
serconvol	entity.name.function	serconvol(x,y): convolution (or Hadamard product) of two power series.
serdiffdep	entity.name.function	serdiffdep(s,p,r): find an inhomogenous linear differential equation satisfied by the series s, with polynomial coefficients of degree <= r. The result is a pair [E,P] such that E(d)(S)=P where E(d) is interpreted as a differential polynomial.
serlaplace	entity.name.function	serlaplace(x): replaces the power series sum of a_n*x^n/n! by sum of a_n*x^n. For the reverse operation, use serconvol(x,exp(X)).
serprec	entity.name.function	serprec(x,v): return the absolute precision x with respect to power series in the variable v.
serreverse	entity.name.function	serreverse(s): reversion of the power series s.
setbinop	entity.name.function	setbinop(f,X,{Y}): the set {f(x,y), x in X, y in Y}. If Y is omitted, assume that X = Y and that f is symmetric.
setdebug	entity.name.function	setdebug({D},{n}): set debug level for domain D to n (n must be between 0 and 20). If n is omitted, return the current level for domain D. if D is omitted, return a two-column matrix which lists the available domains with their levels.
setdelta	entity.name.function	setdelta(x,y): symmetric difference of the sets x and y.
setintersect	entity.name.function	setintersect(x,y): intersection of the sets x and y.
setisset	entity.name.function	setisset(x): true(1) if x is a set (row vector with strictly increasing entries), false(0) if not.
setminus	entity.name.function	setminus(x,y): set of elements of x not belonging to y.
setrand	entity.name.function	setrand(n): reset the seed of the random number generator to n.
setsearch	entity.name.function	setsearch(S,x,{flag=0}): determines whether x belongs to the set (or sorted list) S. If flag is 0 or omitted, returns 0 if it does not, otherwise returns the index j such that x==S[j]. If flag is nonzero, return 0 if x belongs to S, otherwise the index j where it should be inserted.
setunion	entity.name.function	setunion(x,y): union of the sets x and y.
shift	entity.name.function	shift(x,n): shift x left n bits if n>=0, right -n bits if n<0.
shiftmul	entity.name.function	shiftmul(x,n): multiply x by 2^n (n>=0 or n<0).
sigma	entity.name.function	sigma(x,{k=1}): sum of the k-th powers of the divisors of x. k is optional and if omitted is assumed to be equal to 1.
sign	entity.name.function	sign(x): sign of x, of type integer, real or fraction.
simplify	entity.name.function	simplify(x): simplify the object x as much as possible.
sin	entity.name.function	sin(x): sine of x.
sinc	entity.name.function	sinc(x): sinc function of x.
sinh	entity.name.function	sinh(x): hyperbolic sine of x.
sizebyte	entity.name.function	sizebyte(x): number of bytes occupied by the complete tree of the object x.
sizedigit	entity.name.function	sizedigit(x): rough upper bound for the number of decimal digits of (the components of) x. DEPRECATED.
snfrank	entity.name.function	snfrank(D,q): assuming that D is a Smith normal form (i.e. vector of elementary divisors) for some module and q a power of an irreducible element or 0, return the rank of D/qD.
solve	keyword.control	solve(X=a,b,expr): real root of expression expr (X between a and b), where either a or b is infinite or expr(a)*expr(b)<=0.
solvestep	keyword.control	solvestep(X=a,b,step,expr,{flag=0}): find zeros of a function in the real interval [a,b] by naive interval splitting.
sqr	entity.name.function	sqr(x): square of x. NOT identical to x*x.
sqrt	entity.name.function	sqrt(x): square root of x.
sqrtint	entity.name.function	sqrtint(x,{&r}): integer square root y of x, where x is a nonnegative real number. If r is present, set it to the remainder x - y^2.
sqrtn	entity.name.function	sqrtn(x,n,{&z}): nth-root of x, n must be integer. If present, z is set to a suitable root of unity to recover all solutions. If it was not possible, z is set to zero.
sqrtnint	entity.name.function	sqrtnint(x,n): integer n-th root of x, where x is nonnegative real number.
stirling	entity.name.function	stirling(n,k,{flag=1}): if flag=1 (default) return the Stirling number of the first kind s(n,k), if flag=2, return the Stirling number of the second kind S(n,k).
strchr	entity.name.function	strchr(x): converts integer or vector of integers x to a string, translating each integer into a character using ASCII encoding.
strexpand	entity.name.function	strexpand({x}*): concatenates its (string) arguments into a single string, performing tilde expansion.
strjoin	entity.name.function	strjoin(v,{p = ""}): joins the strings in vector v, separating them with delimiter p.
strprintf	entity.name.function	strprintf(fmt,{x}*): returns a string built from the remaining arguments according to the format fmt.
strsplit	entity.name.function	strsplit(s,{p = ""}): splits the string s into a vector of strings, with p acting as a delimiter between successive fields; if p is empty or omitted, split into characters.
strtex	entity.name.function	strtex({x}*): translates its (string) arguments to TeX format and returns the resulting string.
strtime	entity.name.function	strtime(t): return a string describing the time t in milliseconds, in the format used by the GP timer.
subcyclohminus	entity.name.function	subcyclohminus(fH, {p=0}): Let F be the abelian number field contained in Q(zeta_f) corresponding to the subgroup H of (Z/fZ)^*. Let h be the relative class number h^-(F) and Q the Hasse unit index in {1,2}. If Q could be computed, return [h, Q]; else return [2h/Q, 0].
subcycloiwasawa	entity.name.function	subcycloiwasawa(fH, p, {n=0}): Let F be the abelian number field contained in Q(zeta_f) corresponding to the subgroup H of (Z/fZ)^*. Returns the minus part of Iwasawa polynomials attached to the cyclotomic Z_p extension of F.
subcyclopclgp	entity.name.function	subcyclopclgp(fH, p, {flag=0}): Let F be the abelian number field contained in Q(zeta_f) corresponding to the subgroup H of (Z/fZ)^*. Returns the minus part of Iwasawa polynomials attached to the ideal class group of F.
subgrouplist	entity.name.function	subgrouplist(cyc,{bound},{flag=0}): cyc being any object which has a '.cyc' method giving the cyclic components for a finite Abelian group G, outputs the list of subgroups of G (of index bounded by bound, if not omitted), given as HNF left divisors of the SNF matrix corresponding to G. If flag=0 (default) and 'cyc' is a bnr struture output by bnrinit, gives only the subgroups for which the modulus is the conductor.
subst	entity.name.function	subst(x,y,z): in expression x, replace the variable y by the expression z.
substpol	entity.name.function	substpol(x,y,z): in expression x, replace the polynomial y by the expression z, using remainder decomposition of x.
substvec	entity.name.function	substvec(x,v,w): in expression x, make a best effort to replace the variables v1,...,vn by the expression w1,...,wn.
sum	keyword.control	sum(X=a,b,expr,{x=0}): x plus the sum (X goes from a to b) of expression expr.
sumalt	keyword.control	sumalt(X=a,expr,{flag=0}): Cohen-Villegas-Zagier's acceleration of alternating series expr, X starting at a. flag is optional, and can be 0: default, or 1: uses a slightly different method using Zagier's polynomials.
sumdedekind	entity.name.function	sumdedekind(h,k): Dedekind sum attached to h,k.
sumdigits	entity.name.function	sumdigits(n,{B=10}): sum of digits in the integer |n|, when written in base B.
sumdiv	keyword.control	sumdiv(n,X,expr): sum of expression expr, X running over the divisors of n.
sumdivmult	keyword.control	sumdivmult(n,d,expr): sum of multiplicative function expr, d running over the divisors of n.
sumeulerrat	entity.name.function	sumeulerrat(F,{s=1},{a=2}): sum from primes p = a to infinity of F(p^s), where F is a rational function.
sumformal	entity.name.function	sumformal(f,{v}): formal sum of f with respect to v, or to the main variable of f if v is omitted.
suminf	keyword.control	suminf(X=a,expr): naive summation (X goes from a to infinity) of real or complex expression expr.
sumnum	keyword.control	sumnum(n=a,f,{tab}): numerical summation of f(n) from n = a to +infinity using Euler-MacLaurin summation. Assume that f corresponds to a series with positive terms and is a C^oo function; a must be an integer, and tab, if given, is the output of sumnuminit.
sumnumap	keyword.control	sumnumap(n=a,f,{tab}): numerical summation of f(n) from n = a to +infinity using Abel-Plana formula. Assume that f is holomorphic in the right half-plane Re(z) > a; a must be an integer, and tab, if given, is the output of sumnumapinit.
sumnumapinit	entity.name.function	sumnumapinit({asymp}): initialize tables for Abel-Plana summation of a series.
sumnuminit	entity.name.function	sumnuminit({asymp}): initialize tables for Euler-MacLaurin delta summation of a series with positive terms.
sumnumlagrange	keyword.control	sumnumlagrange(n=a,f,{tab}): numerical summation of f(n) from n = a to +infinity using Lagrange summation. a must be an integer, and tab, if given, is the output of sumnumlagrangeinit.
sumnumlagrangeinit	entity.name.function	sumnumlagrangeinit({asymp}, {c1}): initialize tables for Lagrange summation of a series.
sumnummonien	keyword.control	sumnummonien(n=a,f,{tab}): numerical summation from n = a to +infinity using Monien summation.
sumnummonieninit	entity.name.function	sumnummonieninit({asymp},{w},{n0 = 1}): initialize tables for Monien summation of a series with positive terms.
sumnumrat	entity.name.function	sumnumrat(F,a): sum from n = a to infinity of F(n), where F is a rational function of degree less than or equal to -2.
sumnumsidi	keyword.control	sumnumsidi(n=a,f,{safe=1}): numerical summation of f(n) from n = a to +infinity using Sidi summation; a must be an integer. If safe is set to 0, the function is faster but much less robust.
sumpos	keyword.control	sumpos(X=a,expr,{flag=0}): sum of positive (or negative) series expr, the formal variable X starting at a. flag is optional, and can be 0: default, or 1: uses a slightly different method using Zagier's polynomials.
system	entity.name.function	system(str): str being a string, execute the system command str.
tan	entity.name.function	tan(x): tangent of x.
tanh	entity.name.function	tanh(x): hyperbolic tangent of x.
taylor	entity.name.function	taylor(x,t,{d=seriesprecision}): taylor expansion of x with respect to t, adding O(t^d) to all components of x.
teichmuller	entity.name.function	teichmuller(x,{tab}): Teichmuller character of p-adic number x. If x = [p,n], return the lifts of all teichmuller(i + O(p^n)) for i = 1, ..., p-1. Such a vector can be fed back to teichmuller, as the optional argument tab, to speed up later computations.
theta	entity.name.function	theta(q,z): Jacobi sine theta-function.
thetanullk	entity.name.function	thetanullk(q,k): k-th derivative at z=0 of theta(q,z).
thue	entity.name.function	thue(tnf,a,{sol}): solve the equation P(x,y)=a, where tnf was created with thueinit(P), and sol, if present, contains the solutions of Norm(x)=a modulo units in the number field defined by P. If tnf was computed without assuming GRH (flag 1 in thueinit), the result is unconditional. If tnf is a polynomial, compute thue(thueinit(P,0), a).
thueinit	entity.name.function	thueinit(P,{flag=0}): initialize the tnf corresponding to P, that will be used to solve Thue equations P(x,y) = some-integer. If flag is nonzero, certify the result unconditionally. Otherwise, assume GRH (much faster of course).
trace	entity.name.function	trace(x): trace of x.
trap	entity.name.function	trap({e}, {rec}, seq): this function is obsolete, use "iferr". Try to execute seq, trapping runtime error e (all of them if e omitted); sequence rec is executed if the error occurs and is the result of the command.
truncate	entity.name.function	truncate(x,{&e}): truncation of x; when x is a power series,take away the O(X^). If e is present, do not take into account loss of integer part precision, and set e = error estimate in bits.
type	entity.name.function	type(x): return the type of the GEN x.
unexport	keyword.control	unexport(x,...,z): remove x,...,z from the list of variables exported to the parallel world.
unexportall	entity.name.function	unexportall(): empty the list of variables exported to the parallel world.
uninline	keyword.control	uninline(): forget all inline variables. DEPRECATED, use export.
until	keyword.control	until(a,seq): evaluate the expression sequence seq until a is nonzero.
valuation	entity.name.function	valuation(x,{p}): valuation of x with respect to p.
varhigher	entity.name.function	varhigher(name,{v}): return a variable 'name' whose priority is higher than the priority of v (of all existing variables if v is omitted).
variable	entity.name.function	variable({x}): main variable of object x. Gives p for p-adic x, 0 if no variable can be attached to x. Returns the list of user variables if x is omitted.
variables	entity.name.function	variables({x}): all variables occurring in object x, sorted by decreasing priority. Returns the list of user variables if x is omitted.
varlower	entity.name.function	varlower(name,{v}): return a variable 'name' whose priority is lower than the priority of v (of all existing variables if v is omitted.
vecextract	entity.name.function	vecextract(x,y,{z}): extraction of the components of the matrix or vector x according to y and z. If z is omitted, y represents columns, otherwise y corresponds to rows and z to columns. y and z can be vectors (of indices), strings (indicating ranges as in "1..10") or masks (integers whose binary representation indicates the indices to extract, from left to right 1, 2, 4, 8, etc.).
vecmax	entity.name.function	vecmax(x,{&v}): largest entry in the vector/matrix x. If v is present, set it to the index of a largest entry (indirect max).
vecmin	entity.name.function	vecmin(x,{&v}): smallest entry in the vector/matrix x. If v is present, set it to the index of a smallest entry (indirect min).
vecprod	entity.name.function	vecprod(v): return the product of the components of the vector v.
vecsearch	entity.name.function	vecsearch(v,x,{cmpf}): determines whether x belongs to the sorted vector v. If the comparison function cmpf is explicitly given, assume that v was sorted according to vecsort(, cmpf).
vecsort	entity.name.function	vecsort(x,{cmpf},{flag=0}): sorts the vector of vectors (or matrix) x in ascending order, according to the comparison function cmpf, if not omitted. (If cmpf is an integer k, sort according to the value of the k-th component of each entry.) Binary digits of flag (if present) mean: 1: indirect sorting, return the permutation instead of the permuted vector, 4: use descending instead of ascending order, 8: remove duplicate entries.
vecsum	entity.name.function	vecsum(v): return the sum of the components of the vector v.
vector	entity.name.function	vector(n,{X},{expr=0}): row vector with n components of expression expr (X ranges from 1 to n). By default, fills with 0s.
vectorsmall	entity.name.function	vectorsmall(n,{X},{expr=0}): VECSMALL with n components of expression expr (X ranges from 1 to n) which must be small integers. By default, fills with 0s.
vectorv	entity.name.function	vectorv(n,{X},{expr=0}): column vector with n components of expression expr (X ranges from 1 to n). By default, fill with 0s.
version	entity.name.function	version(): returns the PARI version as [major,minor,patch] or [major,minor,patch,GITversion].
warning	entity.name.function	warning({str}*): display warning message str.
weber	entity.name.function	weber(x,{flag=0}): one of Weber's f function of x. flag is optional, and can be 0: default, function f(x)=exp(-i*Pi/24)*eta((x+1)/2)/eta(x), 1: function f1(x)=eta(x/2)/eta(x) 2: function f2(x)=sqrt(2)*eta(2*x)/eta(x). Note that j = (f^24-16)^3/f^24 = (f1^24+16)^3/f1^24 = (f2^24+16)^3/f2^24.
whatnow	entity.name.function	whatnow(key): if key was present in GP version 1.39.15, gives the new function name.
while	keyword.control	while(a,seq): while a is nonzero evaluate the expression sequence seq. Otherwise 0.
write	entity.name.function	write(filename,{str}*): appends the remaining arguments (same output as print) to filename.
write1	entity.name.function	write1(filename,{str}*): appends the remaining arguments (same output as print1) to filename.
writebin	entity.name.function	writebin(filename,{x}): write x as a binary object to file filename. If x is omitted, write all session variables.
writetex	entity.name.function	writetex(filename,{str}*): appends the remaining arguments (same format as print) to filename, in TeX format.
zeta	entity.name.function	zeta(s): Riemann zeta function at s with s a complex or a p-adic number.
zetahurwitz	entity.name.function	zetahurwitz(s,x,{der=0}): Hurwitz zeta function at s, x, with s not 1 and x not a negative or zero integer. s can be a scalar, polynomial, rational function, or power series. If der>0, compute the der'th derivative with respect to s.
zetamult	entity.name.function	zetamult(s,{t=0}): multiple zeta value at integral s = [s1,...,sk]; more generally, return Yamamoto's t-MZV interpolation (star value for t = 1).
zetamultall	entity.name.function	zetamultall(k,{flag=0}): list of all multiple zeta values for weight up to k. Binary digits of flag mean: 0 = zetastar values if set, 1 = values up to duality if set, 2 = values of weight k if set (else all values up to weight k), 3 = return the 2-component vector [Z, M], where M is the vector of the corresponding indices m, i.e., such that zetamult(M[i]) = Z[i].
zetamultconvert	entity.name.function	zetamultconvert(a,{fl=1}): a being either an evec, avec, or index m, converts into evec (fl=0), avec (fl=1), or index m (fl=2).
zetamultdual	entity.name.function	zetamultdual(s): s being either an evec, avec, or index m, return the dual sequence in avec format.
znchar	entity.name.function	znchar(D): given a datum D describing a group G = (Z/NZ)^* and a Dirichlet character chi, return the pair [G,chi].
zncharconductor	entity.name.function	zncharconductor(G,chi): let G be znstar(q,1) and chi be a Dirichlet character on (Z/qZ)*. Return the conductor of chi.
znchardecompose	entity.name.function	znchardecompose(G, chi, Q): given a znstar G = (Z/NZ)^* and a Dirichlet character chi, return the product of local characters chi_p for p | (N,Q).
znchargauss	entity.name.function	znchargauss(G, chi, {a=1}): given a Dirichlet character chi on G = (Z/NZ)^*, return the complex Gauss sum g(chi,a).
zncharinduce	entity.name.function	zncharinduce(G, chi, N): let G be znstar(q,1), let chi be a Dirichlet character mod q and let N be a multiple of q. Return the character modulo N extending chi.
zncharisodd	entity.name.function	zncharisodd(G, chi): let G be znstar(N,1), let chi be a Dirichlet character mod N, return 1 if and only if chi(-1) = -1 and 0 otherwise.
znchartokronecker	entity.name.function	znchartokronecker(G, chi, {flag=0}): let G be znstar(N,1), let chi be a Dirichlet character mod N, return the discriminant D if chi is real equal to the Kronecker symbol (D/.) and 0 otherwise. If flag is set, return the fundamental discriminant attached to the corresponding primitive character.
znchartoprimitive	entity.name.function	znchartoprimitive(G,chi): let G be znstar(q,1) and chi be a Dirichlet character on (Z/qZ)* of conductor q0. Return [G0,chi0], where chi0 is the primitive character attached to chi and G0 is znstar(q0).
znconreychar	entity.name.function	znconreychar(G,m): Dirichlet character attached to m in (Z/qZ)* in Conrey's notation, where G is znstar(q,1).
znconreyconductor	entity.name.function	znconreyconductor(G,chi, {&chi0}): let G be znstar(q,1) and chi be a Dirichlet character on (Z/qZ)* given by its Conrey logarithm. Return the conductor of chi, and set chi0 to (the Conrey logarithm of) the attached primitive character. If chi0 != chi, return the conductor and its factorization.
znconreyexp	entity.name.function	znconreyexp(G, chi): Conrey exponential attached to G = znstar(q, 1). Returns the element m in (Z/qZ)^* attached to the character chi on G: znconreylog(G, m) = chi.
znconreylog	entity.name.function	znconreylog(G,m): Conrey logarithm attached to m in (Z/qZ)*, where G is znstar(q,1).
zncoppersmith	entity.name.function	zncoppersmith(P, N, X, {B=N}): finds all integers x with |x| <= X such that gcd(N, P(x)) >= B. The parameter X should be smaller than exp((log B)^2 / (deg(P) log N)) and the leading coefficient of P should be coprime to N.
znlog	entity.name.function	znlog(x,g,{o}): return the discrete logarithm of x in (Z/nZ)* in base g. If present, o represents the multiplicative order of g. Return [] if no solution exist.
znorder	entity.name.function	znorder(x,{o}): order of the integermod x in (Z/nZ)*. Optional o represents a multiple of the order of the element.
znprimroot	entity.name.function	znprimroot(n): returns a primitive root of n when it exists.
znstar	entity.name.function	znstar(n,{flag=0}): 3-component vector v = [no,cyc,gen], giving the structure of the abelian group (Z/nZ)^*; no is the order (i.e. eulerphi(n)), cyc is a vector of cyclic components, and gen is a vector giving the corresponding generators.
znsubgroupgenerators	entity.name.function	znsubgroupgenerators(H, {flag=0}): find generators of the subgroup H of (Z/fZ)^*; H is given by a vector of 1/0 values: the a-th component is 1 if and only if a belongs to H.
